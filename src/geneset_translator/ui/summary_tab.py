"""Summary tab UI components for LLM-generated category summaries.

This module provides the UI for displaying citation-based summaries
generated by Claude Haiku 4, with interactive citation viewers.
"""

import logging
import os
import re
from typing import List, Dict

import networkx as nx
import streamlit as st

from geneset_translator.core.llm_summarizer import LLMSummarizer, SummaryData, CitationGraph, StagedCategoryQuery

logger = logging.getLogger(__name__)


def render_summary_tab(
    graph: nx.MultiDiGraph,
    query_genes: List[str],
    disease_curie: str,
    infores_metadata: Dict
):
    """Render Summary tab with category summaries and citation viewers.

    Args:
        graph: Knowledge graph
        query_genes: Input gene CURIEs
        disease_curie: Target disease CURIE
        infores_metadata: Knowledge source metadata
    """
    api_key = os.environ.get('ANTHROPIC_API_KEY')

    if not api_key:
        st.warning("âš ï¸ LLM Summary requires ANTHROPIC_API_KEY. Add it to your .env file.")
        st.info("Get your API key from: https://console.anthropic.com/")
        st.code("cp .env.example .env\n# Then add: ANTHROPIC_API_KEY=sk-ant-...", language="bash")
        return

    st.markdown("#### :material/auto_awesome: LLM-Generated Category Summaries")
    st.caption("Citation-based summaries with verifiable evidence from the knowledge graph")

    # LLM Accuracy Warning
    st.warning(
        "**Important:** LLM-generated summaries may contain inaccuracies or hallucinations. "
        "Always verify claims using the **Citation Graph** viewer to trace statements back to "
        "the original knowledge graph edges and publications.",
        icon=":material/warning:"
    )

    # Check if there are any intermediate categories at all (using min_gene_frequency=1)
    all_categories = _get_categories_with_node_counts(graph, query_genes, min_gene_frequency=1)

    if not all_categories:
        st.warning("No intermediate categories found in graph")
        return

    # Control sliders in columns
    col1, col2 = st.columns(2)

    with col1:
        # Max nodes slider for controlling context size and cost
        max_nodes = st.slider(
            "Max Nodes per Category",
            min_value=5,
            max_value=50,
            value=20,
            step=5,
            help="Maximum intermediate nodes to include in each category summary. "
                 "Higher values provide more context but increase token usage and cost.",
            key="summary_max_nodes"
        )

    with col2:
        # Min gene frequency filter
        min_gene_frequency = st.slider(
            "Min Gene Frequency",
            min_value=1,
            max_value=5,
            value=2,
            step=1,
            help="Minimum number of query genes an intermediate must connect to. "
                 "Higher values focus on more convergent nodes but may exclude relevant intermediates.",
            key="summary_min_gene_freq"
        )

    # Filter categories to only show those with intermediates passing the gene_frequency filter
    categories_with_counts = _get_categories_with_node_counts(graph, query_genes, min_gene_frequency)

    if not categories_with_counts:
        st.warning(
            f"No intermediate categories have nodes with gene_frequency â‰¥ {min_gene_frequency}. "
            "Try lowering the Min Gene Frequency filter."
        )
        return

    # Format category options with node counts
    category_options = [cat for cat, count in categories_with_counts]
    category_labels = {cat: f"{cat} ({count} nodes)" for cat, count in categories_with_counts}

    # Category selector
    selected_categories = st.multiselect(
        "Select Categories to Summarize",
        options=category_options,
        default=category_options,
        format_func=lambda x: category_labels.get(x, x),
        help="Choose which node categories to generate summaries for. "
             f"Only categories with nodes having gene_frequency â‰¥ {min_gene_frequency} are shown."
    )

    # Stage queries and compute accurate token counts
    if len(selected_categories) > 0:
        # Create staging key to detect when we need to restage
        staging_key = f"{','.join(sorted(selected_categories))}|{max_nodes}|{min_gene_frequency}|{graph.number_of_edges()}"

        # Only restage if inputs changed
        if st.session_state.get('staging_key') != staging_key:
            with st.spinner("Calculating token counts..."):
                summarizer = LLMSummarizer()
                staged_queries, total_cost = summarizer.stage_all_categories(
                    graph=graph,
                    categories=selected_categories,
                    query_genes=query_genes,
                    disease_curie=disease_curie,
                    max_nodes=max_nodes,
                    min_gene_frequency=min_gene_frequency,
                    infores_metadata=infores_metadata
                )
                st.session_state.staged_queries = {sq.category: sq for sq in staged_queries}
                st.session_state.staging_key = staging_key
                st.session_state.staged_total_cost = total_cost
                st.session_state.min_gene_frequency = min_gene_frequency

        # Display cost breakdown
        staged_queries_dict = st.session_state.get('staged_queries', {})
        total_cost = st.session_state.get('staged_total_cost', 0.0)
        cached_count = sum(1 for sq in staged_queries_dict.values() if sq.is_cached)
        new_count = len(selected_categories) - cached_count

        # Cost summary
        st.markdown(f"**Estimated Cost:** ${total_cost:.4f} ({new_count} new, {cached_count} cached)")

        # Expandable cost breakdown
        with st.expander("View Token Breakdown by Category", expanded=False):
            for category in selected_categories:
                sq = staged_queries_dict.get(category)
                if sq:
                    cache_icon = " ðŸ’¾" if sq.is_cached else ""
                    cost_str = "$0.0000 (cached)" if sq.is_cached else f"${sq.estimated_cost:.4f}"
                    st.markdown(
                        f"**{category}**{cache_icon}: "
                        f"{sq.input_tokens:,} input + ~{sq.output_tokens_estimate:,} output tokens = {cost_str}"
                    )
                    st.caption(
                        f"  Nodes: {sq.nodes_sampled}/{sq.nodes_total} | "
                        f"Edges: {sq.edges_sampled} | "
                        f"Token count via Anthropic API"
                    )

    # Generate button
    generate_btn = st.button(
        "Generate Summaries",
        disabled=len(selected_categories) == 0,
        type="primary"
    )

    # Generate summaries
    if generate_btn:
        summarizer = LLMSummarizer()
        logger.info(f"Starting LLM summary generation for {len(selected_categories)} categories")
        progress_bar = st.progress(0)
        status = st.empty()

        # Get min_gene_frequency from session state (set during staging)
        stored_min_gene_freq = st.session_state.get('min_gene_frequency', min_gene_frequency)

        for i, category in enumerate(selected_categories):
            status.markdown(f"### ðŸ¤– Generating summary for **{category}**...")

            try:
                summary_data = summarizer.generate_category_summary(
                    graph=graph,
                    category=category,
                    query_genes=query_genes,
                    disease_curie=disease_curie,
                    infores_metadata=infores_metadata,
                    max_nodes=max_nodes,
                    min_gene_frequency=stored_min_gene_freq
                )

                # Show if cached or newly generated
                was_cached = summary_data.metadata.get('from_cache', False)
                cache_indicator = "ðŸ’¾" if was_cached else "âœ¨"

                st.session_state.summaries[category] = summary_data
                logger.info(f"{'Loaded cached' if was_cached else 'Generated'} summary for {category}: {len(summary_data.citations)} citations")
                status.markdown(f"{cache_indicator} **{category}** {'(cached)' if was_cached else '(generated)'}")

            except Exception as e:
                logger.error(f"Failed to generate summary for {category}: {e}")
                st.error(f"âŒ Failed to generate summary for {category}: {e}")

            progress_bar.progress((i + 1) / len(selected_categories))

        status.markdown("âœ… All summaries generated!")
        st.rerun()

    # Display existing summaries
    if st.session_state.summaries:
        st.divider()

        for category, summary_data in st.session_state.summaries.items():
            render_category_summary(category, summary_data, graph, query_genes)


def _get_categories_with_node_counts(
    graph: nx.MultiDiGraph,
    query_genes: List[str],
    min_gene_frequency: int
) -> List[tuple]:
    """Get intermediate categories with counts of nodes passing the gene_frequency filter.

    Args:
        graph: Knowledge graph
        query_genes: Query gene CURIEs
        min_gene_frequency: Minimum gene_frequency threshold

    Returns:
        List of (category, count) tuples, sorted by category name.
        Only includes categories with at least one node passing the filter.
    """
    query_genes_set = set(query_genes)
    category_counts: Dict[str, int] = {}

    for node, data in graph.nodes(data=True):
        # Skip query genes themselves
        if node in query_genes_set:
            continue

        category = data.get('category')
        if not category:
            continue

        gene_freq = data.get('gene_frequency', 0)

        # Check if node passes the gene_frequency filter
        if gene_freq >= min_gene_frequency:
            # Verify it's actually intermediate (connected to query genes)
            neighbors = set(graph.predecessors(node)) | set(graph.successors(node))
            if any(n in query_genes_set for n in neighbors):
                category_counts[category] = category_counts.get(category, 0) + 1

    # Return sorted list of (category, count) tuples, excluding empty categories
    return sorted(
        [(cat, count) for cat, count in category_counts.items() if count > 0],
        key=lambda x: x[0]
    )


def render_category_summary(category: str, summary_data: SummaryData, graph: nx.MultiDiGraph, query_genes: List[str]):
    """Render summary for a single category.

    Args:
        category: Category name
        summary_data: Summary data with citations
        graph: Full knowledge graph
        query_genes: Input gene CURIEs for pathway display
    """
    with st.expander(f"ðŸ“Š {category}", expanded=True):
        # Metadata row
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Citations", len(summary_data.citations), border=True)
        with col2:
            nodes_total = summary_data.metadata.get('nodes_total', 0)
            nodes_sampled = summary_data.metadata.get('nodes_sampled', 0)
            sampling = summary_data.metadata.get('sampling_strategy', 'unknown')

            sampling_labels = {
                'full': 'Full Context',
                'medium_sample': 'Medium Sample',
                'large_sample': 'Large Sample'
            }

            st.metric(
                "Nodes Analyzed",
                f"{nodes_sampled} / {nodes_total}",
                help=f"Sampling: {sampling_labels.get(sampling, 'Unknown')}",
                border=True
            )
        with col3:
            timestamp = summary_data.metadata.get('timestamp', '')
            if timestamp:
                st.caption(f"Generated: {timestamp[:10]}")

        # Convert citation markers to clickable links
        summary_with_links = _convert_citations_to_links(summary_data.summary_text, category)
        st.markdown(summary_with_links, unsafe_allow_html=True)

        # Citations section
        if summary_data.citations:
            st.markdown("##### Citations")

            for citation in summary_data.citations:
                render_citation_card(citation, category, graph, query_genes)


def _convert_citations_to_links(summary_text: str, category: str) -> str:
    """Convert [Citation N] markers to clickable HTML anchors.

    Args:
        summary_text: Summary text with citation markers
        category: Category name for unique anchors

    Returns:
        HTML string with clickable citation links
    """
    def replace_citation(match):
        citation_num = match.group(1)
        anchor_id = f"citation_{category}_{citation_num}"
        return f'<a href="#{anchor_id}" style="color: #FF6B6B; text-decoration: none; font-weight: bold;">[Citation {citation_num}]</a>'

    return re.sub(r'\[Citation (\d+)\]', replace_citation, summary_text)


def render_citation_card(citation: CitationGraph, category: str, graph: nx.MultiDiGraph, query_genes: List[str]):
    """Render a citation card with nodes, edges, and publications.

    Args:
        citation: Citation data
        category: Category name
        graph: Full knowledge graph
        query_genes: Input gene CURIEs for pathway display
    """
    anchor_id = f"citation_{category}_{citation.citation_id}"

    with st.container(border=True):
        st.markdown(f'<div id="{anchor_id}"></div>', unsafe_allow_html=True)
        st.markdown(f"**Citation {citation.citation_id}**: {citation.claim}")

        # Cited nodes
        if citation.node_ids:
            st.markdown("**Cited Nodes:**")
            for node_id in citation.node_ids[:10]:  # Limit display
                node_data = graph.nodes.get(node_id, {})
                label = node_data.get('label', node_id)
                gene_freq = node_data.get('gene_frequency', 0)
                st.markdown(f"- `{node_id}` ({label}) - Gene frequency: {gene_freq}")

        # Cited edges
        if citation.edge_ids:
            st.markdown("**Cited Edges:**")
            for edge_id in citation.edge_ids[:5]:  # Limit display
                st.markdown(f"- `{edge_id}`")

        # Publications
        if citation.publication_ids:
            st.markdown("**Publications:**")
            pub_links = []
            for pub_id in citation.publication_ids[:10]:  # Limit display
                link = _format_publication_link(pub_id)
                pub_links.append(link)
            st.markdown(" | ".join(pub_links), unsafe_allow_html=True)

        # View citation graph button
        if st.button(
            "View Citation Graph",
            key=f"view_citation_{category}_{citation.citation_id}",
            help="Visualize cited nodes and edges in interactive graph"
        ):
            # Store citation for viewing
            st.session_state.active_citation = {
                'citation': citation,
                'category': category
            }

    # If this citation is active, render the viewer
    if hasattr(st.session_state, 'active_citation'):
        active = st.session_state.active_citation
        if active['citation'].citation_id == citation.citation_id and active['category'] == category:
            from geneset_translator.ui.citation_viewer import render_citation_viewer
            with st.container(border=True):
                st.markdown("##### Citation Graph Viewer")
                render_citation_viewer(citation, graph, query_genes=query_genes, category=category)


def _format_publication_link(pub_id: str) -> str:
    """Format publication ID as clickable HTML link.

    Args:
        pub_id: Publication ID (PMID:12345, PMC:PMC123456, DOI:...)

    Returns:
        HTML link string
    """
    if pub_id.startswith('PMID:'):
        pmid = pub_id.split(':')[1]
        return f'<a href="https://pubmed.ncbi.nlm.nih.gov/{pmid}" target="_blank">{pub_id}</a>'
    elif pub_id.startswith('PMC:'):
        pmc = pub_id.split(':')[1]
        return f'<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/{pmc}" target="_blank">{pub_id}</a>'
    elif pub_id.startswith('DOI:'):
        doi = pub_id.split(':', 1)[1]
        return f'<a href="https://doi.org/{doi}" target="_blank">{pub_id}</a>'
    else:
        return pub_id
