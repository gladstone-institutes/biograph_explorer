https://github.com/NCATSTranslator/ReasonerAPI
================================================
FILE: README.md
================================================
# Translator Reasoner API

[![ReasonerAPI build status on Travis CI](https://travis-ci.org/NCATSTranslator/ReasonerAPI.svg?branch=master)](https://travis-ci.org/NCATSTranslator/ReasonerAPI)

The Translator Reasoner API (TRAPI) defines a standard HTTP API for communicating biomedical questions and answers. It leverages the [Biolink model](https://github.com/biolink/biolink-model/) to precisely describe the semantics of biological entities and relationships. TRAPI's graph-based query-knowledge-binding structure enables expressive yet concise description of biomedical questions and answers.

TRAPI is described primarily by an [OpenAPI](https://github.com/OAI/OpenAPI-Specification) document [here](TranslatorReasonerAPI.yaml). The complete request/response structure is also documented in a more human-readable form [here](docs/reference.md).

## Example

A simple but meaningful question asks "What drugs treat type-2 diabetes?". Answers could include for example "metformin" and "glyburide". Let's walk through how such a question could be asked and answering using TRAPI.

### Query graph

Each question is framed as a [directed graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Directed_graph) where biomedical entities are represented by nodes and relationships between them are represented by (directed) edges.

This question includes two nodes, "type-2 diabetes" and a "drug", and one edge, "treats". The basic "query graph" therefore looks like this:

```json
{
    "nodes": {
        "type-2 diabetes": {"ids": ["MONDO:0005148"]},
        "drug": {"categories": ["biolink:Drug"]}
    },
    "edges": {
        "treats": {"subject": "drug", "predicates": ["biolink:treats"], "object": "type-2 diabetes"}
    }
}
```

TRAPI requires the values for `ids`, `categories`, and `predicates` to be [CURIEs](https://en.wikipedia.org/wiki/CURIE) in order to unambiguously identify the specific entities, entity categories, and relationship predicates. Other constraints on these values are detailed in [the schema reference](docs/reference.md). The node and edge keys have no bearing on the query graph semantics, so you can choose simple placeholders (e.g. "n01"/"e02") or human-readable names, as above. Note that the node "drug" has no `ids`; that's what we want to find out! The query graph can thus be thought of as a template for an answer to the question.

### Knowledge graph

A collection of biomedical knowledge can be represented in a similar format, but where each node must be fully specified.

```json
{
    "nodes": {
        "MONDO:0005148": {"name": "type-2 diabetes"},
        "CHEBI:6801": {"name": "metformin", "categories": ["biolink:Drug"]}
    },
    "edges": {
        "df87ff82": {"subject": "CHEBI:6801", "predicate": "biolink:treats", "object": "MONDO:0005148"}
    }
}
```

In a "knowledge graph", the node keys _are_ semantically meaningful; they must be CURIEs identifying biomedical entities, equivalent to the `ids` from the query graph. Other constraints on these values are detailed in [the schema reference](docs/reference.md).  

In TRAPI lingo, a knowledge graph is not an answer, it is just knowledge. Answering a question involves mapping knowledge onto a question.

### Results

Each "result", or answer to the question, is a set of "bindings" between the knowledge graph and query graph. In our simple example, the knowledge-graph node "MONDO:0005148" will be bound to the query-graph node "type-2 diabetes" and the knowledge-graph node "CHEBI:6801" will be bound to the query-graph node "drug". The knowledge-graph edge "df87ff82" will be bound to the query-graph edge "treats".

```json
{
    "node_bindings": {
        "type-2 diabetes": [{"id": "MONDO:0005148"}],
        "drug": [{"id": "CHEBI:6801"}]
    },
    "edge_bindings": {
        "treats": [{"id": "df87ff82"}]
    }
}
```

This format allows concise communication of the knowledge relevant to a question and precisely how it is used to formulate answers.

### Message

The query graph, knowledge graph, and results together form a "message":

```json
{
    "query_graph": {
        "nodes": {
            "type-2 diabetes": {"ids": ["MONDO:0005148"]},
            "drug": {"categories": ["biolink:Drug"]}
        },
        "edges": {
            "treats": {"subject": "drug", "predicates": ["biolink:treats"], "object": "type-2 diabetes"}
        }
    },
    "knowledge_graph": {
        "nodes": {
            "MONDO:0005148": {"name": "type-2 diabetes"},
            "CHEBI:6801": {"name": "metformin", "categories": ["biolink:Drug"]}
        },
        "edges": {
            "df87ff82": {"subject": "CHEBI:6801", "predicate": "biolink:treats", "object": "MONDO:0005148"}
        }
    },
    "results": [
        {
            "node_bindings": {
                "type-2 diabetes": [{"id": "MONDO:0005148"}],
                "drug": [{"id": "CHEBI:6801"}]
            },
            "edge_bindings": {
                "treats": [{"id": "df87ff82"}]
            }
        }
    ]
}
```

The client receiving this message in response to the initial query graph has only to look at what is bound to "drug" to find the answer to their question.

These messages form the backbone of TRAPI. They are transmitted between clients and servers implementing TRAPI by including them in the body of a POST request/response, along with any other meta-information:

```json
{
    "message": {
        "query_graph": ...,
        "knowledge_graph": ...,
        "results": ...
    },
    "other information": ...
}
```

## Contributing

TRAPI is developed by The [Biomedical Data Translator](https://ncats.nih.gov/translator) Consortium. Consortium members and external contributors are encouraged to submit issues and pull requests. See the [development policies](Policies.md) for guidelines on branches and versioning.



================================================
FILE: ChangeLog.md
================================================
# Change Log TRAPI 1.4.0 (2023-06-23) -> 1.5.0 (2023-05-26)

https://github.com/NCATSTranslator/ReasonerAPI/compare/v1.4.0...1.5
  
- Add x-trapi pathfinderquery: true/false
  https://github.com/NCATSTranslator/ReasonerAPI/pull/487/files
  
- Add x-trapi multicuriequery: true/false
  https://github.com/NCATSTranslator/ReasonerAPI/pull/488/files
  
- Fix minor syntax errors
  https://github.com/NCATSTranslator/ReasonerAPI/pull/485/files
  
- Update knowledge_level_agent_type_specification.md
  https://github.com/NCATSTranslator/ReasonerAPI/pull/486/files
  
- Add QNode.member_ids
  https://github.com/NCATSTranslator/ReasonerAPI/pull/481/files
  
- Change workflow schema to https and version 1.3.5
  https://github.com/NCATSTranslator/ReasonerAPI/commit/aeddb4323ed9fd5aead5986c5e5ffbab167e6524
  https://github.com/NCATSTranslator/ReasonerAPI/commit/1fdd0351c8edfb59d8fcf52dfe387f5547f1fc27
  https://github.com/NCATSTranslator/ReasonerAPI/commit/6c4215a92a5895cdb9062124700a5c84b5e1c249
  
- Revert OneOf to additionalProperties (TRAPI 1.4.2 correction)
  https://github.com/NCATSTranslator/ReasonerAPI/commit/795b13836bde2042687cbd7927f10e6dbee923e1
  https://github.com/NCATSTranslator/ReasonerAPI/commit/98077dd71f6c582ff71ac32719c708c118132245

- Make Query.message a oneOf $ref and nullable false
  https://github.com/NCATSTranslator/ReasonerAPI/commit/1f9a9828a1dbeb146bb34de9b8bda2277895b985

- Fix ambiguiities in Response
  https://github.com/NCATSTranslator/ReasonerAPI/commit/55ccfdfa9a9988a1f271dd28708c9ade0fc347bf

- convert to oneOf with -
  https://github.com/NCATSTranslator/ReasonerAPI/commit/505ddb954310eab37d58d37be881006751dda5e2

- Fix EdgeBinding and AuxGraph
  https://github.com/NCATSTranslator/ReasonerAPI/commit/91cd63b174b81d6d7629ae478f0a8d4eb4bd60ec

- Insert missing dashes at lines 267 and 320
  https://github.com/NCATSTranslator/ReasonerAPI/commit/c17fe1be1dbc131800cfab444a7b739b8b75a3cc
  https://github.com/NCATSTranslator/ReasonerAPI/commit/ffb2fedf1a8788e75714e9f140afee936feba060

- Make attributes required with minItems 0
  https://github.com/NCATSTranslator/ReasonerAPI/commit/e5f52be4f47391e8f3496dcfc538c0764a5824b3

- Make Query.message a oneOf $ref and nullable false
  https://github.com/NCATSTranslator/ReasonerAPI/commit/cc2b67d1c5f93dd62c934080c11607a2e15c5100

- Fix EdgeBinding and AuxGraph
  https://github.com/NCATSTranslator/ReasonerAPI/commit/6d5bfdb7cff85a216df3830fce36a63db22976d3

- Set_interpretation and is_set changes
  https://github.com/NCATSTranslator/ReasonerAPI/pull/475/files

- Add bypass_cache
  https://github.com/NCATSTranslator/ReasonerAPI/pull/473/files
  Implementation note: bypass_cache MUST be passed down to downstream queries: ARS -> ARAs -> KP2 -> NodeNorm

- Clarify minItems 1 for Attributes
  https://github.com/NCATSTranslator/ReasonerAPI/pull/472/files

- Clarify NodeBinding
  https://github.com/NCATSTranslator/ReasonerAPI/pull/468/files

- Make Message.Results minItems 0
  https://github.com/NCATSTranslator/ReasonerAPI/pull/464/files

- Make logs minItems: 1
  https://github.com/NCATSTranslator/ReasonerAPI/pull/466/files

- Clarify Result
  Not yet merged. Abrar checking on a potential snag
  https://github.com/NCATSTranslator/ReasonerAPI/pull/467/files

Documentation updates:

- Update retrieval_provenance_specification
  https://github.com/NCATSTranslator/ReasonerAPI/commit/78dafcf07f33dc0511e8a18c7f801fd68226d73e
  https://github.com/NCATSTranslator/ReasonerAPI/commit/4d3e457b7e46425548cf855562127e67de2757e5

- Update supporting_publications_specification
  https://github.com/NCATSTranslator/ReasonerAPI/commit/b856d79c4df1fe2dbba937ddb339019958cb1150

Minor updates during the beta phase:

- Pending









# Change Log TRAPI 1.3 (2022-09-01) -> 1.4-beta (2023-03-23)

https://github.com/NCATSTranslator/ReasonerAPI/compare/v1.3.0...1.4
  
- Edge.predicate switched to nullable false and made required, Edge.subject and Edge.object switched to nullable false
  https://github.com/NCATSTranslator/ReasonerAPI/pull/377/files

- External workflow schema updated from version 1.0.0 to version 1.3.2 
  https://github.com/NCATSTranslator/ReasonerAPI/pull/365/files
  
- Node.categories clarified that they SHOULD be Biolink Model categories and MUST NOT be of type 'abstract' or 'mixin'. 'deprecated' categories SHOULD also be avoided.
  https://github.com/NCATSTranslator/ReasonerAPI/pull/383/files

- In MetaKnowledgeGraph component, added MetaEdge.qualifiers as list of new MetaQualifier types
  https://github.com/NCATSTranslator/ReasonerAPI/pull/387/files
 
- Add /async_query_status/{job_id} endpoint
  https://github.com/NCATSTranslator/ReasonerAPI/pull/395/files
  
- Constrain Qualifier.qualifier_type_id to be a biolink CURIE
  https://github.com/NCATSTranslator/ReasonerAPI/pull/391/files
 
- Encoding extra supporting graph information in TRAPI
  This is a complex breaking change that moves Result.edge_bindings into Result.analyses which link to AuxiliaryGraph objects
  https://github.com/NCATSTranslator/ReasonerAPI/pull/389/files

- Enhance encoding of EPC retrieval sources by adding Edge.sources as list of RetrievalSource items (required, minItems: 1)
  https://github.com/NCATSTranslator/ReasonerAPI/pull/393/files

- Switch all cases of "allOf" to "oneOf" to be compatible with actual schema semantics and TRAPI (JSONSchema) validation
  https://github.com/NCATSTranslator/ReasonerAPI/pull/403/files

- New properties Response.schema_version and Response.biolink_version to aid in TRAPI (JSONSchema) validation
  https://github.com/NCATSTranslator/ReasonerAPI/pull/405/files

Minor updates during the beta phase:

- Everyone should be tagging at 1.4.0: https://github.com/NCATSTranslator/ReasonerAPI/pull/419/files

- Change RetrievalSource.resource and upstream_resources to RetrievalSource.resource_id and upstream_resource_ids for consistency:
  https://github.com/NCATSTranslator/ReasonerAPI/pull/418/files

- Change Analysis.reasoner_id to Analysis.resource_id

- Version v1.4.0-beta2 was corrupted somehow and should not be used. It is replaced by v1.4.0-beta3


# Change Log TRAPI 1.2 -> 1.3

https://github.com/NCATSTranslator/ReasonerAPI/compare/v1.2.0...1.3
  
- Add test_data_location in x-trapi
  https://github.com/NCATSTranslator/ReasonerAPI/pull/339/files

- Add flag for knowledge_type flag for Creative Mode
  https://github.com/NCATSTranslator/ReasonerAPI/pull/331/files

- Add support for Qualifiers in KGs and queries
  https://github.com/NCATSTranslator/ReasonerAPI/pull/330/files

- Add knowledge_types support to /meta_knowledge_graph
  https://github.com/NCATSTranslator/ReasonerAPI/pull/333/files

- Add === operator to Constraint
  https://github.com/NCATSTranslator/ReasonerAPI/commit/875112b7a349c9f8e89bb5660725af5c895c9a24

- Clarified meaning of batch_size_limit
  https://github.com/NCATSTranslator/ReasonerAPI/commit/ad3c16a3ecc085cc041b0ebbeeb7f0803e054fd0

- Misc documentation fixes

- Add NodeBinding.query_id property. Optional but a substantial change to current practice
  https://github.com/NCATSTranslator/ReasonerAPI/commit/dc6e864af5e498f7e420318b16be7d4a2f9a03ef

- Clarification on expectations for /meta_knowledge_graph for KPs and ARAs
  https://github.com/NCATSTranslator/ReasonerAPI/commit/e2ed87aa4f02dac55dcbd8eac7e190b8c188fbdd

- Permit unlimited recursion of attributes
  https://github.com/NCATSTranslator/ReasonerAPI/commit/6ec8ea28f3262ac163803622017bb651a4adac33

- Added NodeBinding.Attributes

- Clarification on how to properly to specify KP "allowlist"s and "denylist"s via constraints
  https://github.com/NCATSTranslator/ReasonerAPI/commit/82218fc86be74755ec1ffa9b8679eac0075df364

- Clarification on previously-agreed handling of QNode and QEdge additional properties
  https://github.com/NCATSTranslator/ReasonerAPI/commit/85fefd44925652a5b2e9648fef1d6c70c5099ea9


# Change Log TRAPI 1.1 -> 1.2
- /predicates endpoint is REMOVED
  https://github.com/NCATSTranslator/ReasonerAPI/pull/261/files

- Removed all 'relation' properties in Edge, QEdge, MetaEdge

- /meta_knowledge_graph allows optional attributes[] property (encouraged but not required)
  https://github.com/NCATSTranslator/ReasonerAPI/pull/259/files

- Add support for workflow and operations v1.0.0 (encouraged but not yet required)
  https://github.com/NCATSTranslator/ReasonerAPI/pull/262/files

- /asyncquery endpoint added (recommended but not required)
  https://github.com/NCATSTranslator/ReasonerAPI/pull/255/files
  https://github.com/NCATSTranslator/ReasonerAPI/pull/263/files

- Add result.score (highly encouraged but not required)
  https://github.com/NCATSTranslator/ReasonerAPI/pull/247/files

- /meta_knowledge_graph should only include specific relationships, not ancestor-inferred relationships (policy clarification)

- Add one level of subattributes to Attribute
  https://github.com/NCATSTranslator/ReasonerAPI/pull/268/files

- Add attributes[] to EdgeBinding to complement Edge and Node
  https://github.com/NCATSTranslator/ReasonerAPI/pull/269/files

- QNode.constraints and QEdge.constraints no longer nullable. Now use empty list as default instead of null
  https://github.com/NCATSTranslator/ReasonerAPI/pull/286/files


# Change Log TRAPI 1.0 -> 1.1
- Many changes to "info" template at top. Please refresh to the latest template
- info.version is now your API version not TRAPI version
- x-trapi now contains the official TRAPI version
- x-translator now contains mandatory metadata
- Remove tag "reasoner". Add tag "trapi"
- /predicates endpoint is marked deprecated
- New /meta_knowledge_graph endpoint replaces /predicates endpoint. Note that counts are optional as defined in extended schema
- log_level property in Query specifies desired logging level in Response
- QNode.id pluralized to ids and changed from CURIE or array of CURIEs to just array of CURIEs with array length > 0
- QNode.category pluralized to categories and changed from BiolinkEntity or array of BiolinkEntitys to just array of BiolinkEntitys with array length > 0
- QNode.predicate pluralized to predicates and changed from BiolinkPredicate or array of BiolinkPredicates to just array of BiolinkPredicates with array length > 0
- Attribute class extended and properties renamed
- QNode.constraints and QEdge.constraints as array of Constraint added



================================================
FILE: Policies.md
================================================
# Translator Reasoner API Policies

This document described development and release policies for the Translator Reasoner API.

## Stable branches
- The repository has two "stable" branches, `master` and `extended`
- The `master` branch contains the latest stable version of the core API schema
- The `extended` branch contains the latest stable extended API schema, a definition of additional properties that are used and promoted by at least one team

## In-development branches
- The repository may contain a number of branches for pre-release versions, e.g. `v1.1.x`

## Version numbering
- Each merge into master must include a version bump
- The `extended` branch shall maintain the same version number as `master`



================================================
FILE: requirements.txt
================================================
tox
pyyaml
requests
jsonschema
pytest
reasoner-validator


================================================
FILE: tox.ini
================================================
[tox]
envlist = py39
skipsdist = True

[testenv]
deps =
    jsonschema
    pytest
    pyyaml
    requests
    yamllint
    reasoner-validator
passenv =
    TOXENV
    CI
    TRAVIS
    TRAVIS_*
commands =
    yamllint TranslatorReasonerAPI.yaml
    pytest



================================================
FILE: voting_members.md
================================================
# TRAPI-Working Group-Tracking-Voting
Weekly meetings on Thursday's, 1 pm ET.
After initial formation - roster should be maintained at the consortium level Translator Committees & Working Groups
|Committee Member Name|Committee Member Team|Role|Email|
|--|--|--|--|
|Eric Deutsch|Team Expander Agent|Voting Member|edeutsch@systemsbiology.org
|Casey Ta|Connections Hypothesis Provider|Voting Member|ct2865@columbia.edu
|Bill Baumgartner|Text Mining Provider|Voting Member|william.baumgartner@cuanshutz.edu
|Will Byrd|Unsecret Agent|Voting Member|webyrd@uab.edu
|Richard Bruskiewich|SRI|Voting Member|richard.bruskiewich@delphinai.com
|Patrick Wang|Ranking Agent|Voting Member|patrick@covar.com
|Ryan Roper|Multiomics Provider|Voting Member|ryan.roper@isbscience.org
|Marc Duby|Genetics Provider|Voting Member|mduby@broadinstitute.org
|Mark Williams|Molecular Data Provider|Voting Member|mark.williams5@nih.gov
|Vlado Dancik|Unsecret Agent|Voting Member|vdancik@broadinstitute.org
|Steve Cox|SRI|Voting Member|scox@renci.org
|Chase Yakaboski|Connection Hypothesis Provider|Voting Member|chase.a.yakaboski.th@dartmouth.edu
|Andrew Su|Exploring Agent|Voting Member|asu@scripps.edu
|Brett Smith|(im)Prove Agent|Voting Member|brett.smith@isbscience.org
|Tom Zisk|(Im)Explanatory Agent|Voting Member|tz@iomics.us
|Kent Shefchek|SRI|Voting Member|shefchek@oregonstate.edu
|Shawn Oâ€™Neil|SRI|Voting Member|oneils@oregonstate.edu



================================================
FILE: .travis.yml
================================================
dist: xenial
language: python
python:
  - "3.9"
install:
  - pip install tox
script: 
  - tox


================================================
FILE: .yamllint.yml
================================================
extends: default

rules:
  document-start: disable
  empty-values:
    forbid-in-block-mappings: true
  line-length:
    max: 79
  quoted-strings:
    quote-type: single
    required: only-when-needed



================================================
FILE: API/README.md
================================================
# Translator Reasoner API

This API specification represents a version 0.9.3-dev draft of the Translator Reasoner API.
Previous releases (e.g. 0.9.2, 0.9.1) are tagged.
It is intended that NCATS Translator ARS, Autonomous Reasoning Agents (ARAs), and Knowledge Providers (KPs)
will support this API so that remote calls to
any of these services (and other related Translator resources) may be made using the same API
with the same result format, which will
facilitate comparison among reasoners and chaining of queries to different reasoners to
achieve an aggregated result.

## The Core and Extended
- The `master` branch contains the core schema, a minimal schema that all implementations must have code to handle
- The `extended` branch contains extensions to the schema that enable the encoding of substantially more information,
  but clients and servers are not required to implement handling for these items.

## Previous versions
- Previous versions of the draft standard may be found at https://github.com/NCATS-Tangerine/NCATS-ReasonerStdAPI/tree/7205051d69e50d2c8137d88598346e185f920ea4/API

## Notes
- The following documentation is now badly out of date, but generally reflects the year-old state of the `extended` schema
- The target output is intended to be JSON-LD
- Updated 2019-03-08

# INPUT Specification
Below is a description of the elements of the JSON formatted input to the /query endpoint.
Note that at present all parameters are optional and the endpoint handler will look at what
is provided and decide if it can proceed with the input given.

## Top level (Query class)
- **bypass_cache** - string - Set to true in order to bypass any possible cached message and try to answer the query over again (e.g.:  "true")                                             
- **asynchronous** - string - Set to true in order to receive an incomplete message_id if the query will take a while. Client can then periodically request that message_id for a status update and eventual complete message (e.g.:  "false")                                                                                                                                          
- **max_results** - integer - Maximum number of individual results to return (e.g.:  100)                                                                                                   
- **page_size** - integer - Split the results into pages with this number of results each (e.g.:  20)                                                                                       
- **page_number** - integer - Page number of results when the number of results exceeds the page_size (e.g.:  1)                                                                            
- **reasoner_ids** - array - List of reasoners to consult for the query (e.g.:  [ "RTX", "Robokop" ])                                                                                       
- **query_message** - object - Message object that represents the query to be answered (e.g.: ) which contains a [query graph representing the structure of a query](https://github.com/NCATS-Tangerine/NCATS-ReasonerStdAPI/blob/master/API/TranslatorReasonersAPI.yaml#L664).                                                                                           
- **previous_message_processing_plan** - object - Container for one or more Message objects or identifiers for one or more Messages along with a processing plan for how those messages should be processed and returned (e.g.: ).                                                                                                                                                  
## PreviousMessageProcessingPlan
- **previous_message_uris** - array - List of URIs for Message objects to fetch and process (e.g.:  [ "https://rtx.ncats.io/api/rtx/v1/message/300" ])
- **previous_messages** - array - List of Message objects to process (e.g.: ) similar to the ones referenced by **query_message** above, containing a [query graph object representing the structure of a query](https://github.com/NCATS-Tangerine/NCATS-ReasonerStdAPI/blob/master/API/TranslatorReasonersAPI.yaml#L664).
- **processing_actions** - array - List of order-dependent actions to guide what happens with the Message object(s) (e.g.:  [ "mod45filter", "redirect2RTX" ])
- **options** - object - Dict of options that apply during processing in an order independent fashion (e.g.:  [ "topNMostFrequent" ])



# OUTPUT Specification
Below is a description of the elements of the JSON formatted output.

## Top level (Message class)
- **context** - string - JSON-LD context URI (e.g.:  "https://rtx.ncats.io/ns/translator.jsonld")
- **type** - string - Entity type of this message (e.g.:  "translator_reasoner_message")
- **id** - string - URI for this message (e.g.:  "https://rtx.ncats.io/api/rtx/v1/message/123")
- **reasoner_id** - string - Identifier string of the reasoner that provided this message (one of RTX, Robokop, Indigo, Integrator, etc.) (e.g.:  "reasoner")
- **tool_version** - string - Version label of the tool that generated this message (e.g.:  "RTX 0.5.0")
- **schema_version** - string - Version label of this JSON-LD schema (e.g.:  "0.9.0")
- **datetime** - string - Datetime string for the time that this message was generated (e.g.:  "2018-01-09 12:34:45")
- **n_results** - integer - Total number of results from the query (which may be less than what is returned if limits were placed on the number of results to return) (e.g.:  42)
- **message_code** - string - Set to OK for success, or some other short string to indicate and error (e.g., KGUnavailable, TermNotFound, etc.) (e.g.:  "OK")
- **code_description** - string - Extended description denoting the success or mode of failure in the generation of the message (e.g.:  "9 results found")
- **table_column_names** - array - List of column names that corresponds to the row_data for each result (e.g.:  [ "chemical_substance.name", "chemical_substance.id" ])
- **original_question** - string - The original question text typed in by the user (e.g.:  "what proteins are affected by sickle cell anemia")
- **restated_question** - string - A precise restatement of the question, as understood by the Translator, for which the answer applies. The user should verify that the restated question matches the intent of their original question (it might not). (e.g.:  "Which proteins are affected by sickle cell anemia?")
- **query_type_id** - string - The query type id if one is known for the query/message (as defined in https://docs.google.com/spreadsheets/d/18zW81wteUfOn3rFRVG0z8mW-ecNhdsfD_6s73ETJnUw/edit#gid=1742835901 ) (e.g.:  "Q2")
- **terms** - object - Dict of terms needed by the specific query type (e.g.: )
- **query_options** - object - Dict of options that can be sent with the query. Options are tool specific and not stipulated here (e.g.:  "{coalesce=True,threshold=0.9}")
- **results** - array - List of all returned potential answers for the query posed (e.g.: )
- **query_graph** - object - QueryGraph object that contains a serialization of a query in the form of a graph (e.g.: )
- **knowledge_graph** - object - KnowledgeGraph object that contains all the nodes and edges referenced in any of the possible answers to the query (e.g.: ) **OR** a RemoteKnowledgeGraph object that contains connection information for a remote knowledge graph that is a substitute for local KnowledgeGraph contained in this Message (e.g.: )


## Result (each object within results)
- **id** - string - URI for this message (e.g.:  "https://rtx.ncats.io/api/rtx/v1/result/234")
- **description** - string - A free text description of this result answer from the reasoner (e.g.:  "The genetic condition sickle cell anemia may provide protection\)
- **essence** - string - A single string that is the terse essence of the result (useful for simple answers) (e.g.:  "ibuprofen")
- **essence_type** - string - A Translator bioentity type of the essence (e.g.:  "drug")
- **row_data** - array - An arbitrary list of values that captures the essence of the result that can be turned into a tabular result across all answers (each result is a row) for a user that wants tabular output (e.g.:  [ "ibuprofen", "CHEMBL:CHEMBL521" ])
- **score** - number - Any type of score associated with this result (e.g.:  163.233)
- **score_name** - string - Name for the score (e.g.:  "Jaccard distance")
- **score_direction** - string - Sorting indicator for the score: one of higher_is_better or lower_is_better (e.g.:  "lower_is_better")
- **confidence** - number - Confidence metric for this result, a value between (inclusive) 0.0 (no confidence) and 1.0 (highest confidence) (e.g.:  0.9234)
- **result_type** - string - One of several possible result types: 'individual query answer', 'neighborhood graph', 'type summary graph' (e.g.:  "individual query answer")
- **result_group** - integer - An integer group number for results for use in cases where several results should be grouped together. Also useful to control sorting ascending. (e.g.:  "1")
- **result_group_similarity_score** - number - A score that denotes the similarity of this result to other members of the result_group (e.g.:  0.95)
- **reasoner_id** - string - Identifier string of the reasoner that provided this result (e.g., RTX, Robokop, Indigo, Integrator) (e.g.:  "RTX")
- **result_graph** - object - A graph that describes the thought pattern of this result (i.e. answer to the query) (e.g.: )
- **node_bindings** - object - Lookup dict that maps QNode (internal) identifiers in the QueryGraph to Node identifiers (CURIEs) in the KnowledgeGraph (e.g.: { "n00": [ "HP:0001878" ] })
- **edge_bindings** - object - Lookup dict that maps QEdge (internal) identifiers in the QueryGraph to Edge (internal) identifiers in the KnowledgeGraph (e.g.: { "e00": [ "0001" ] })

## KnowledgeGraph
- **nodes** - array - List of nodes in the KnowledgeGraph (e.g.: )
- **edges** - array - List of edges in the KnowledgeGraph (e.g.: )

## RemoteKnowledgeGraph
- **url** - string - URL that provides programmatic access to the remote knowledge graph (e.g.:  "http://robokop.renci.org/api/kg")
- **credentials** - object - Credentials needed for programmatic access to the remote knowledge graph (e.g.: )

## Credentials
- **username** -  string - Username needed for programmatic access to the remote knowledge graph (e.g.: )
- **password** -  string - Password needed for programmatic access to the remote knowledge graph (e.g.: )

## QueryGraph
- **nodes** - array - List of nodes in the QueryGraph (e.g.: )
- **edges** - array - List of edges in the QueryGraph (e.g.: )

## QNode
- **node_id** - string - QueryGraph internal identifier for this QNode. Recommended form: n00, n01, n02, etc. (e.g.:  "n00")
- **curie** - string - CURIE identifier for this node (e.g.:  "OMIM:603903")
- **type** - string - Entity type of this node (e.g., protein, disease, etc.) (e.g.:  "disease")

## QEdge
- **edge_id** - string - QueryGraph internal identifier for this QEdge. Recommended form: e00, e01, e02, etc. (e.g.:  "e00")
- **type** - string - Higher-level relationship type of this edge (e.g.:  "affects")
- **relation** - string - Lower-level relationship type of this edge (e.g.:  "upregulates")
- **source_id** - string - Corresponds to the @id of source node of this edge (e.g.:  "https://omim.org/entry/603903")
- **target_id** - string - Corresponds to the @id of target node of this edge (e.g.:  "https://www.uniprot.org/uniprot/P00738")
- **negated** - boolean - Boolean that if set to true, indicates the edge statement is negated i.e. is not true (e.g.:  "true")

## Node
- **id** - string - CURIE identifier for this node (e.g.:  "OMIM:603903")
- **uri** - string -  URI identifier for this node (e.g.:  "https://www.uniprot.org/uniprot/P00738")
- **name** - string - Formal name of the entity (e.g.:  "Haptoglobin")
- **type** - array - Entity type of this node (e.g., protein, disease, etc.) (e.g.:  [ "protein" ])
- **description** - string - One to three sentences of description/definition of this entity (e.g.:  "Haptoglobin captures, and combines with free plasma hemoglobin...")
- **symbol** - string - Short abbreviation or symbol for this entity (e.g.:  "HP")
- **node_attributes** - array - A list of arbitrary attributes for the node (e.g.: )

## NodeAttribute
- **type** - string - Entity type of this attribute (e.g.:  "article")
- **name** - string - Formal name of the attribute (e.g.:  "Wikipedia article")
- **value** - string - Value of the attribute (e.g.:  "7.23e-12")
- **url** - string - A URL corresponding to this attribute (e.g.:  "https://en.wikipedia.org/wiki/Malaria")

## Edge
- **id** - string - Local identifier for this node which is unique within this KnowledgeGraph, and perhaps within the source reasoner's knowledge graph (e.g.:  "553903")
- **type** - string - Higher-level relationship type of this edge (e.g.:  "affects")
- **relation** - string - Lower-level relationship type of this edge (e.g.:  "upregulates")
- **source_id** - string - Corresponds to the @id of source node of this edge (e.g.:  "https://omim.org/entry/603903")
- **target_id** - string - Corresponds to the @id of target node of this edge (e.g.:  "https://www.uniprot.org/uniprot/P00738")
- **is_defined_by** - string - A CURIE/URI for the translator group that made the KG (e.g.:  "reasoner")
- **defined_datetime** - string - Datetime at which the KG builder/updater pulled the information from the original source. Used as a freshness indicator. (e.g.:  "2018-11-03 15:34:23")
- **provided_by** - string - A CURIE/URI for the knowledge source that defined this edge (e.g.:  "OMIM")
- **confidence** - number - Confidence metric for this edge, a value between (inclusive) 0.0 (no confidence) and 1.0 (highest confidence) (e.g.:  0.99)
- **weight** - number - Weight metric for this edge, with no upper bound. Perhaps useful when formal confidence metrics are not available (e.g.:  0.99)
- **publications** - array - List of CURIEs for publications associated with this edge (e.g.:  [ "PMID:12345562" ])
- **evidence_type** - string - A CURIE/URI for class of evidence supporting the statement made in an edge - typically a class from the ECO ontology (e.g.:  "ECO:0000220")
- **qualifiers** - string - Terms representing qualifiers that modify or qualify the meaning of the statement made in an edge (e.g.:  "ECO:0000220")
- **negated** - boolean - Boolean that if set to true, indicates the edge statement is negated i.e. is not true (e.g.:  "true")
- **edge_attributes** - array - A list of additional attributes for this edge (e.g.: )

## EdgeAttribute
- **type** - string - Entity type of this attribute (e.g.:  "localization")
- **name** - string - Formal name of the attribute (e.g.:  "Cell type limitation")
- **value** - string - Value of the attribute. While all attributes should have a name, many will not have a value (e.g.:  "MFC cells")
- **url** - string - A URL corresponding to this attribute (e.g.:  "https://www.ncbi.nlm.nih.gov/pubmed/29309293")

## Feedback
- **id** - string - URI for this feedback item (e.g.:  "https://rtx.ncats.io/api/rtx/v1/result/234/feedback/56")
- **result_id** - string - URI for the result that this feedback corresponds to (e.g.:  "https://rtx.ncats.io/api/rtx/v1/result/234")
- **expertise_level_id** - integer - Integer identifier of the claimed expertise level (e.g.:  "1")
- **rating_id** - integer - Integer identifier of the applied rating (e.g.:  "1")
- **commenter_id** - integer - Integer identifier of the commenter (e.g.:  "1")
- **commenter_full_name** - string - Full name of the commenter (e.g.:  "John Smith")
- **datetime** - string - Datetime when the feedback was provided (e.g.:  "2018-05-08 12:00")
- **comment** - string - A free text comment about this result (e.g.:  "This is a great result because...")

## ResultFeedback
- **feedback_list** - array - List of feedback posts for this result (e.g.: )

## MessageFeedback
- **feedback_list** - array - List of feedback posts for this entire message (e.g.: )



================================================
FILE: API/ReadmeGenerator.py
================================================
# Class for autogenerating content for the README.md file based on the YAML file
import os
import sys
import re

class ReadmeGenerator:
  def __init__(self):
    self.read_api_file()

  #### Define attribute questions
  @property
  def questions(self) -> str:
    return self._questions

  @questions.setter
  def questions(self, questions: list):
    self._questions = questions

  def read_api_file(self):
    with open(os.path.join(os.path.dirname(__file__), 'TranslatorReasonersAPI_0.9.0.yaml'), 'r') as fid:
      state = "beginning"
      yaml_class = ""
      attribute_name = "??"
      type = "??"
      description = "??"
      example = ""
      questions = []
      for line in fid.readlines():
        if line[0] == "#":
          continue
        if state == "beginning":
          if re.match("definitions:",line):
            state = "definitions"
          continue

        match = re.match("  (\S+):",line)
        if match:
          yaml_class = match.group(1)
          print("- **"+attribute_name+"** - "+type+" - "+description+" (e.g.: "+example+")")
          attribute_name = "??"
          type = "??"
          description = "??"
          example = ""
          print()
          print("## "+yaml_class)

        match = re.match("      (\S+):",line)
        if match:
          if attribute_name != "??":
            print("- **"+attribute_name+"** - "+type+" - "+description+" (e.g.: "+example+")")
          attribute_name = "??"
          type = "??"
          description = "??"
          example = ""
          attribute_name = match.group(1)

        match = re.match("        type:(.+)",line)
        if match:
          type = match.group(1)
          type = re.sub("^\s*\"", "", type)
          type = re.sub("\"\s*", "", type)

        match = re.match("        description:(.+)",line)
        if match:
          description = match.group(1)
          description = re.sub("^\s*\"", "", description)
          description = re.sub("\"\s*", "", description)

        match = re.match("        example:(.+)",line)
        if match:
          example = match.group(1)
          

    print("- **"+attribute_name+"** - "+type+" - "+description+" (e.g.: "+example+")")

def main():
  readme = ReadmeGenerator()

if __name__ == "__main__":
  main()



================================================
FILE: docs/generate_reference.py
================================================
"""Generate README."""
import os
import re

from jinja2 import Environment, FileSystemLoader
import yaml
from yaml.loader import SafeLoader

THIS_DIR = os.path.dirname(os.path.abspath(__file__))


def link_refs(string):
    """Hyperlink refs."""
    return re.sub(
        r"\"\$ref\": \"#/components/schemas/(\w+)\"",
        r"\"$ref\": \"(#/components/schemas/\g<1>)[\g<1>]\"",
        string,
    )


class SafeLineLoader(SafeLoader):
    def construct_mapping(self, node, deep=False):
        mapping = super().construct_mapping(node, deep=deep)
        # Add 1 so line numbering starts at 1
        mapping['_start'] = node.start_mark.line
        mapping['_end'] = node.end_mark.line
        return mapping


def main():
    """Generate README."""
    yamlpath = os.path.join(
        THIS_DIR,
        "TranslatorReasonerAPI.yaml",
    )

    j2_env = Environment(
        loader=FileSystemLoader(THIS_DIR),
        trim_blocks=False,
        keep_trailing_newline=True,
        extensions=[
            "jinja2.ext.do",
        ]
    )

    with open(yamlpath, 'r') as stream:
        data = yaml.load(stream, Loader=SafeLineLoader)
    components = data['components']
    schemas = components['schemas']

    sha = "master"

    markdown = j2_env.get_template('reference_template.md').render(
        schemas=schemas,
        sha=sha,
    )

    with open('reference.md', 'w') as stream:
        stream.write(markdown.encode('cp850', 'replace').decode('utf-8', 'replace'))


if __name__ == "__main__":
    main()



================================================
FILE: docs/PROBLEM_NOTES.txt
================================================
Note from Eric on 2025-06-02:

The autogen scripts did not seem to work with the Base** inheritance setup.

So I copied the yaml in the parent directory into this directory and manually copied over
all the properties from the Base classes to the inheriting classes so that the docgen worked correctly.



================================================
FILE: docs/reference.md
================================================
# Translator Reasoner API

## Components

#### Query [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L255:L306)

The Query class is used to package a user request for information. A Query object consists of a required Message object with optional additional properties. Additional properties are intended to convey implementation-specific or query-independent parameters. For example, an additional property specifying a log level could allow a user to override the default log level in order to receive more fine-grained log information when debugging an issue.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
message | [Message](#message-) | **REQUIRED**. The query Message is a serialization of the user request. Content of the Message object depends on the intended TRAPI operation. For example, the fill operation requires a non-empty query_graph field as part of the Message, whereas other operations, e.g. overlay, require non-empty results and knowledge_graph fields.
log_level | [LogLevel](#loglevel-) | The least critical level of logs to return
workflow | [workflow](#workflow-) | List of workflow steps to be executed.
submitter | `string` | Any string for self-identifying the submitter of a query. The purpose of this optional field is to aid in the tracking of the source of queries for development and issue resolution.
bypass_cache | `boolean` | Set to true in order to request that the agent obtain fresh information from its sources in all cases where it has a viable choice between requesting fresh information in real time and using cached information. The agent receiving this flag MUST also include it in TRAPI sent to downstream sources (e.g., ARS -> ARAs -> KPs).

#### AsyncQuery [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L307:L368)

The AsyncQuery class is effectively the same as the Query class but it requires a callback property.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
callback | `string` | **REQUIRED**. Upon completion, this server will send a POST request to the callback URL with `Content-Type: application/json` header and request body containing a JSON-encoded `Response` object. The server MAY POST `Response` objects before work is fully complete to provide interim results with a Response.status value of 'Running'. If a POST operation to the callback URL does not succeed, the server SHOULD retry the POST at least once.
message | [Message](#message-) | **REQUIRED**. The query Message is a serialization of the user request. Content of the Message object depends on the intended TRAPI operation. For example, the fill operation requires a non-empty query_graph field as part of the Message, whereas other operations, e.g. overlay, require non-empty results and knowledge_graph fields.
log_level | [LogLevel](#loglevel-) | The least critical level of logs to return
workflow | [workflow](#workflow-) | List of workflow steps to be executed.
submitter | `string` | Any string for self-identifying the submitter of a query. The purpose of this optional field is to aid in the tracking of the source of queries for development and issue resolution.
bypass_cache | `boolean` | Set to true in order to request that the agent obtain fresh information from its sources in all cases where it has a viable choice between requesting fresh information in real time and using cached information. The agent receiving this flag MUST also include it in TRAPI sent to downstream sources (e.g., ARS -> ARAs -> KPs).

#### AsyncQueryResponse [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L369:L399)

The AsyncQueryResponse object contains a payload that must be returned from a submitted async_query.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
status | `string` | One of a standardized set of short codes: e.g. Accepted, QueryNotTraversable, KPsNotAvailable
description | `string` | A brief human-readable description of the result of the async_query submission.
job_id | `string` | **REQUIRED**. An identifier for the submitted job that can be used with /async_query_status to receive an update on the status of the job.

#### AsyncQueryStatusResponse [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L400:L443)

The AsyncQueryStatusResponse object contains a payload that describes the current status of a previously submitted async_query.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
status | `string` | **REQUIRED**. One of a standardized set of short codes: Queued, Running, Completed, Failed
description | `string` | **REQUIRED**. A brief human-readable description of the current state or summary of the problem if the status is Failed.
logs | [[LogEntry](#logentry-)] | **REQUIRED**. A list of LogEntry items, containing errors, warnings, debugging information, etc. List items MUST be in chronological order with earliest first. The most recent entry should be last. Its timestamp will be compared against the current time to see if there is still activity.
response_url | `string` | Optional URL that can be queried to restrieve the full TRAPI Response.

#### Response [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L444:L500)

The Response object contains the main payload when a TRAPI query endpoint interprets and responds to the submitted query successfully (i.e., HTTP Status Code 200). The message property contains the knowledge of the response (query graph, knowledge graph, and results). The status, description, and logs properties provide additional details about the response.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
message | [Message](#message-) | **REQUIRED**. Contains the knowledge of the response (query graph, knowledge graph, and results).
status | `string` | One of a standardized set of short codes, e.g. Success, QueryNotTraversable, KPsNotAvailable
description | `string` | A brief human-readable description of the outcome
logs | [[LogEntry](#logentry-)] | A list of LogEntry items, containing errors, warnings, debugging information, etc. List items MUST be in chronological order with earliest first.
workflow | [workflow](#workflow-) | List of workflow steps that were executed.
schema_version | `string` | Version label of the TRAPI schema used in this document
biolink_version | `string` | Version label of the Biolink model used in this document

#### Message [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L501:L551)

The message object holds the main content of a Query or a Response in three properties: query_graph, results, and knowledge_graph. The query_graph property contains the query configuration, the results property contains any answers that are returned by the service, and knowledge_graph property contains lists of edges and nodes in the thought graph corresponding to this message. The content of these properties is context-dependent to the encompassing object and the TRAPI operation requested.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
results | [[Result](#result-)] | List of all returned Result objects for the query posed. The list SHOULD NOT be assumed to be ordered. The 'score' property, if present, MAY be used to infer result rankings. If Results are not expected (such as for a query Message), this property SHOULD be null or absent. If Results are expected (such as for a response Message) and no Results are available, this property SHOULD be an array with 0 Results in it.
query_graph | [QueryGraph](#querygraph-) \| [PathfinderQueryGraph](#pathfinderquerygraph-) | QueryGraph object that contains a serialization of a query in the form of a graph
knowledge_graph | [KnowledgeGraph](#knowledgegraph-) | KnowledgeGraph object that contains lists of nodes and edges in the thought graph corresponding to the message
auxiliary_graphs | Map[`string`, [AuxiliaryGraph](#auxiliarygraph-)] | Dictionary of AuxiliaryGraph instances that are used by Knowledge Graph Edges and Result Analyses. These are referenced elsewhere by the dictionary key.

#### LogEntry [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L552:L593)

The LogEntry object contains information useful for tracing and debugging across Translator components.  Although an individual component (for example, an ARA or KP) may have its own logging and debugging infrastructure, this internal information is not, in general, available to other components. In addition to a timestamp and logging level, LogEntry includes a string intended to be read by a human, along with one of a standardized set of codes describing the condition of the component sending the message.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
timestamp | `string` | **REQUIRED**. Timestamp in ISO 8601 format, providing the LogEntry time either in univeral coordinated time (UTC) using the 'Z' tag (e.g 2020-09-03T18:13:49Z), or, if local time is provided, the timezone offset must be provided (e.g. 2020-09-03T18:13:49-04:00).
level | [LogLevel](#loglevel-) | 
code | `string` | One of a standardized set of short codes e.g. QueryNotTraversable, KPNotAvailable, KPResponseMalformed
message | `string` | **REQUIRED**. A human-readable log message

#### LogLevel [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L594:L601)

Logging level

`string`

one of:
* ERROR
* WARNING
* INFO
* DEBUG

#### Result [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L602:L639)

A Result object specifies the nodes and edges in the knowledge graph that satisfy the structure or conditions of a user-submitted query graph. It must contain a NodeBindings object (list of query graph node to knowledge graph node mappings) and a list of Analysis objects.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
node_bindings | Map[`string`, [[NodeBinding](#nodebinding-)]] | **REQUIRED**. The dictionary of Input Query Graph to Result Knowledge Graph node bindings where the dictionary keys are the key identifiers of the Query Graph nodes and the associated values of those keys are instances of NodeBinding schema type (see below). This value is an array of NodeBindings since a given query node may have multiple knowledge graph Node bindings in the result.
analyses | [[Analysis](#analysis-) \| [PathfinderAnalysis](#pathfinderanalysis-)] | **REQUIRED**. The list of all Analysis components that contribute to the result. See below for Analysis components.

#### NodeBinding [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L640:L684)

An instance of NodeBinding is a single KnowledgeGraph Node mapping, identified by the corresponding 'id' object key identifier of the Node within the Knowledge Graph. Instances of NodeBinding may include extra annotation in the form of additional properties. (such annotation is not yet fully standardized). Each Node Binding must bind directly to node in the original Query Graph.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
id | [CURIE](#curie-) | **REQUIRED**. The CURIE of a Node within the Knowledge Graph.
query_id | [CURIE](#curie-) | An optional property to provide the CURIE in the QueryGraph to which this binding applies. If the bound QNode does not have an an 'id' property or if it is empty, then this query_id MUST be null or absent. If the bound QNode has one or more CURIEs as an 'id' and this NodeBinding's 'id' refers to a QNode 'id' in a manner where the CURIEs are different (typically due to the NodeBinding.id being a descendant of a QNode.id), then this query_id MUST be provided. In other cases, there is no ambiguity, and this query_id SHOULD NOT be provided.
attributes | [[Attribute](#attribute-)] | **REQUIRED**. A list of attributes providing further information about the node binding. This is not intended for capturing node attributes and should only be used for properties that vary from result to result.

#### BaseAnalysis [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L685:L733)

An analysis is a dictionary that contains information about the result tied to a particular service. Each Analysis is generated by a single reasoning service, and describes the outputs of analyses performed by the reasoner on a particular Result (e.g. a result score), along with provenance information supporting the analysis (e.g. method or data that supported generation of the score).

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
resource_id | [CURIE](#curie-) | **REQUIRED**. The id of the resource generating this Analysis
score | `number` | A numerical score associated with this result indicating the relevance or confidence of this result relative to others in the returned set. Higher MUST be better.
support_graphs | [`string`] | This is a list of references to Auxiliary Graph instances that supported the analysis of a Result as performed by the reasoning service. Each item in the list is the key of a single Auxiliary Graph.
scoring_method | `string` | An identifier and link to an explanation for the method used to generate the score
attributes | [[Attribute](#attribute-)] | The attributes of this particular Analysis.

#### Analysis [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L734:L791)

An analysis for results from a non-Pathfinder query SHOULD have edge_bindings and SHOULD NOT have path_bindings

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
resource_id | [CURIE](#curie-) | **REQUIRED**. The id of the resource generating this Analysis
score | `number` | A numerical score associated with this result indicating the relevance or confidence of this result relative to others in the returned set. Higher MUST be better.
support_graphs | [`string`] | This is a list of references to Auxiliary Graph instances that supported the analysis of a Result as performed by the reasoning service. Each item in the list is the key of a single Auxiliary Graph.
scoring_method | `string` | An identifier and link to an explanation for the method used to generate the score
attributes | [[Attribute](#attribute-)] | The attributes of this particular Analysis.
edge_bindings | Map[`string`, [[EdgeBinding](#edgebinding-)]] | **REQUIRED**. The dictionary of input Query Graph to Knowledge Graph edge bindings where the dictionary keys are the key identifiers of the Query Graph edges and the associated values of those keys are instances of EdgeBinding schema type (see below). This value is an array of EdgeBindings since a given query edge may resolve to multiple Knowledge Graph Edges.

#### PathfinderAnalysis [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L792:L843)

An analysis for results from a Pathfinder query SHOULD have path_bindings and SHOULD NOT have edge_bindings

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
resource_id | [CURIE](#curie-) | **REQUIRED**. The id of the resource generating this Analysis
score | `number` | A numerical score associated with this result indicating the relevance or confidence of this result relative to others in the returned set. Higher MUST be better.
support_graphs | [`string`] | This is a list of references to Auxiliary Graph instances that supported the analysis of a Result as performed by the reasoning service. Each item in the list is the key of a single Auxiliary Graph.
scoring_method | `string` | An identifier and link to an explanation for the method used to generate the score
attributes | [[Attribute](#attribute-)] | The attributes of this particular Analysis.
path_bindings | Map[`string`, [[PathBinding](#pathbinding-)]] | **REQUIRED**. The dictionary of input Query Graph paths to Analysis paths, specifically only for pathfinder queries.

#### EdgeBinding [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L844:L873)

A instance of EdgeBinding is a single KnowledgeGraph Edge mapping, identified by the corresponding 'id' object key identifier of the Edge within the Knowledge Graph. Instances of EdgeBinding may include extra annotation (such annotation is not yet fully standardized). Edge bindings are captured within a specific reasoner's Analysis object because the Edges in the Knowledge Graph that get bound to the input Query Graph may differ between reasoners.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
id | `string` | **REQUIRED**. The key identifier of a specific KnowledgeGraph Edge.
attributes | [[Attribute](#attribute-)] | **REQUIRED**. A list of attributes providing further information about the edge binding. This is not intended for capturing edge attributes and should only be used for properties that vary from result to result.

#### PathBinding [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L874:L887)

A instance of PathBinding is a single binding of an input QueryGraph path (the key to this object) with the AuxiliaryGraph id containing a list of edges in the path. The Auxiliary Graph does not convey any order of edges in the path.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
id | `string` | **REQUIRED**. The key identifier of a specific auxiliary graph.

#### AuxiliaryGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L888:L923)

A single AuxiliaryGraph instance that is used by Knowledge Graph Edges, Result Analysis support graphs, and Path Bindings.  Edges comprising an Auxiliary Graph are a subset of the  Knowledge Graph in the message. Data creators can  create an AuxiliaryGraph to assemble a specific collection of edges from the Knowledge Graph into a named graph that can be referenced from an Edge as evidence/explanation supporting that Edge, from a Result Analysis as information used to generate a score, or  from a Path Binding as the path for that Analysis.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
edges | [`string`] | **REQUIRED**. List of edges that form the Auxiliary Graph. Each item is a reference to a single Knowledge Graph Edge. This list is not ordered, nor is the order intended to convey any relationship  between the edges that form this Auxiliary Graph.
attributes | [[Attribute](#attribute-)] | **REQUIRED**. Attributes of the Auxiliary Graph

#### KnowledgeGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L924:L951)

The knowledge graph associated with a set of results. The instances of Node and Edge defining this graph represent instances of biolink:NamedThing (concept nodes) and biolink:Association (relationship edges) representing (Attribute) annotated knowledge returned from the knowledge sources and inference agents wrapped by the given TRAPI implementation.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
nodes | Map[`string`, [Node](#node-)] | **REQUIRED**. Dictionary of Node instances used in the KnowledgeGraph, referenced elsewhere in the TRAPI output by the dictionary key.
edges | Map[`string`, [Edge](#edge-)] | **REQUIRED**. Dictionary of Edge instances used in the KnowledgeGraph, referenced elsewhere in the TRAPI output by the dictionary key.

#### BaseQueryGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L952:L969)

A graph representing a biomedical question. It serves as a template for each result (answer), where each bound knowledge graph node/edge is expected to obey the constraints of the associated query graph element.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
nodes | Map[`string`, [QNode](#qnode-)] | **REQUIRED**. The node specifications. The keys of this map are unique node identifiers and the corresponding values include the constraints on bound nodes.

#### QueryGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L970:L995)

A non-Pathfinder query SHOULD have edges following the QEdge schema and SHOULD NOT have paths

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
nodes | Map[`string`, [QNode](#qnode-)] | **REQUIRED**. The node specifications. The keys of this map are unique node identifiers and the corresponding values include the constraints on bound nodes.
edges | Map[`string`, [QEdge](#qedge-)] | **REQUIRED**. The edge specifications. The keys of this map are unique edge identifiers and the corresponding values include the constraints on bound edges, in addition to specifying the subject and object QNodes.

#### PathfinderQueryGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L996:L1023)

A Pathfinder query SHOULD have paths following the QPath schema and SHOULD NOT have edges

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
nodes | Map[`string`, [QNode](#qnode-)] | **REQUIRED**. The node specifications. The keys of this map are unique node identifiers and the corresponding values include the constraints on bound nodes.
paths | Map[`string`, [QPath](#qpath-)] | **REQUIRED**. The QueryGraph path specification, used only for pathfinder type queries. The keys of this map are unique path identifiers and the corresponding values include the constraints on bound paths, in addition to specifying the subject, object, and intermediate QNodes.

#### QNode [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1024:L1096)

A node in the QueryGraph used to represent an entity in a query. If a CURIE is not specified, any nodes matching the category of the QNode will be returned in the Results.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
ids | [[CURIE](#curie-)] | A CURIE identifier (or list of identifiers) for this node.  The 'ids' field will hold a list of CURIEs only in the case of a BATCH set_interpretation, where each CURIE is queried  separately. If a list of queried CURIEs is to be considered as a   set (as under a MANY or ALL set_interpretation), the 'ids' field  will hold a single id representing this set, and the individual members  of this set will be captured in a separate 'member_ids' field.  Note that the set id MUST be created as a UUID by the system that  defines the queried set, using a centralized nodenorm service.  Note also that downstream systems MUST re-use the original set UUID  in the messages they create/send, which will facilitate merging or  caching operations.
categories | [[BiolinkEntity](#biolinkentity-)] | These should be Biolink Model categories and are allowed to be of type 'abstract' or 'mixin' (only in QGraphs!). Use of 'deprecated' categories should be avoided.
set_interpretation | `string` | Indicates how multiple CURIEs in the ids property MUST be interpreted. BATCH indicates that the query is intended to be a batch query and each CURIE is treated independently. ALL means that all specified CURIES MUST appear in each Result. MANY means that member CURIEs MUST form one or more sets in the Results, and sets with more members are generally considered more desirable that sets with fewer members. If this property is missing or null, the default is BATCH.
member_ids | [[CURIE](#curie-)] | A list of CURIE identifiers for members of a queried set. This  field MUST be populated under a set_interpretation of MANY or ALL, when the 'ids' field holds a UUID representing the set  itself. This field MUST NOT be used under a set_interpretation  of BATCH.
constraints | [[AttributeConstraint](#attributeconstraint-)] | A list of constraints applied to a query node. If there are multiple items, they must all be true (equivalent to AND)

#### QEdge [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1097:L1171)

An edge in the QueryGraph used as a filter pattern specification in a query. If the optional predicate property is not specified, it is assumed to be a wildcard match to the target knowledge space. If specified, the ontological inheritance hierarchy associated with the term provided is assumed, such that edge bindings returned may be an exact match to the given QEdge predicate term, or to a term that is a descendant of the QEdge predicate term.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
knowledge_type | `string` | Indicates the type of knowledge that the client wants from the server between the subject and object. If the value is 'lookup', then the client wants direct lookup information from knowledge sources. If the value is 'inferred', then the client wants the server to get creative and connect the subject and object in more speculative and non-direct-lookup ways. If this property is absent or null, it MUST be assumed to mean 'lookup'. This feature is currently experimental and may be further extended in the future.
predicates | [[BiolinkPredicate](#biolinkpredicate-)] | These should be Biolink Model predicates and are allowed to be of type 'abstract' or 'mixin' (only in QGraphs!). Use of 'deprecated' predicates should be avoided.
subject | `string` | **REQUIRED**. Corresponds to the map key identifier of the subject concept node anchoring the query filter pattern for the query relationship edge.
object | `string` | **REQUIRED**. Corresponds to the map key identifier of the object concept node anchoring the query filter pattern for the query relationship edge.
attribute_constraints | [[AttributeConstraint](#attributeconstraint-)] | A list of attribute constraints applied to a query edge. If there are multiple items, they must all be true (equivalent to AND)
qualifier_constraints | [[QualifierConstraint](#qualifierconstraint-)] | A list of QualifierConstraints that provide nuance to the QEdge. If multiple QualifierConstraints are provided, there is an OR relationship between them. If the QEdge has multiple predicates or if the QNodes that correspond to the subject or object of this QEdge have multiple categories or multiple curies, then qualifier_constraints MUST NOT be specified because these complex use cases are not supported at this time.

#### QPath [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1172:L1219)

A path in the QueryGraph used for pathfinder queries. Both subject and object MUST reference QNodes that have a CURIE in their ids field. Paths returned that bind to this QPath can represent some relationship between subject and object.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
subject | `string` | **REQUIRED**. Corresponds to the map key identifier of the subject concept node for the start of the queried path.
object | `string` | **REQUIRED**. Corresponds to the map key identifier of the object concept node for the end of the queried path.
predicates | [[BiolinkPredicate](#biolinkpredicate-)] | QPath predicates are intended to convey what type of paths are desired, NOT a constraint on the types of predicates that may be in result paths. If no predicate is listed, the ARA SHOULD find paths such that the relationship represented by the path is a "related_to" relationship. These should be Biolink Model predicates and are allowed to be of type 'abstract' or 'mixin' (only in QGraphs!). Use of 'deprecated' predicates should be avoided.
constraints | [[PathConstraint](#pathconstraint-)] | A list of constraints for the QPath. If multiple constraints are listed, it should be interpreted as an OR relationship. Each path returned is required to comply with at least one constraint.

#### PathConstraint [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1220:L1236)

A constraint for paths. ARAs must comply with constraints when finding paths.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
intermediate_categories | [[BiolinkEntity](#biolinkentity-)] | A list of Biolink model categories by which to constrain paths returned. If multiple categories are listed, it should be interpreted as an AND relationship. Each path returned by ARAs MUST contain at least one node of each category listed.

#### Node [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1237:L1276)

A node in the KnowledgeGraph which represents some biomedical concept. Nodes are identified by the keys in the KnowledgeGraph Node mapping.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
name | `string` | Formal name of the entity
categories | [[BiolinkEntity](#biolinkentity-)] | **REQUIRED**. These should be Biolink Model categories and are NOT allowed to be of type 'abstract' or 'mixin'. Returning 'deprecated' categories should also be avoided.
attributes | [[Attribute](#attribute-)] | **REQUIRED**. A list of attributes describing the node
is_set | `boolean` | Indicates that the node represents a set of entities. If this property is missing or null, it is assumed to be false.

#### Attribute [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1277:L1362)

Generic attribute for a node or an edge that expands the key-value pair concept by including fields for additional metadata. These fields can be used to describe the source of the statement made in a key-value pair of the attribute object, or describe the attribute's value itself including its semantic type, or a url providing additional information about it. An attribute may be further qualified with sub-attributes (for example to provide confidence intervals on a value).

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
attribute_type_id | [CURIE](#curie-) | **REQUIRED**. The 'key' of the attribute object, holding a CURIE of an ontology property defining the attribute (preferably the CURIE of a Biolink association slot). This property captures the relationship asserted to hold between the value of the attribute, and the node or edge from  which it hangs. For example, that a value of '0.000153' represents a p-value supporting an edge, or that a value of 'ChEMBL' represents the original source of the knowledge expressed in the edge.
original_attribute_name | `string` | The term used by the original source of an attribute to describe the meaning or significance of the value it captures. This may be a column name in a source tsv file, or a key in a source json document for the field in the data that held the attribute's value. Capturing this information  where possible lets us preserve what the original source said. Note that the data type is string' but the contents of the field could also be a CURIE of a third party ontology term.
value | any | **REQUIRED**. Value of the attribute. May be any data type, including a list.
value_type_id | [CURIE](#curie-) | CURIE describing the semantic type of an  attribute's value. Use a Biolink class if possible, otherwise a term from an external ontology. If a suitable CURIE/identifier does not exist, enter a descriptive phrase here and submit the new type for consideration by the appropriate authority.
attribute_source | `string` | The source of the core assertion made by the key-value pair of an attribute object. Use a CURIE or namespace designator for this resource where possible.
value_url | `string` | Human-consumable URL linking to a web document that provides additional information about an  attribute's value (not the node or the edge fom which it hangs).
description | `string` | Human-readable description for the attribute and its value.
attributes | [[Attribute](#attribute-)] | A list of attributes providing further information about the parent attribute (for example to provide provenance information about the parent attribute).

#### Edge [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1363:L1427)

A specification of the semantic relationship linking two concepts that are expressed as nodes in the knowledge "thought" graph resulting from a query upon the underlying knowledge source.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
predicate | [BiolinkPredicate](#biolinkpredicate-) | **REQUIRED**. The type of relationship between the subject and object for the statement expressed in an Edge. These should be Biolink Model predicate terms and are NOT allowed to be of type 'abstract' or 'mixin'. Returning 'deprecated' predicate terms should also be avoided.
subject | [CURIE](#curie-) | **REQUIRED**. Corresponds to the map key CURIE of the subject concept node of this relationship edge.
object | [CURIE](#curie-) | **REQUIRED**. Corresponds to the map key CURIE of the object concept node of this relationship edge.
attributes | [[Attribute](#attribute-)] | A list of additional attributes for this edge
qualifiers | [[Qualifier](#qualifier-)] | A set of Qualifiers that act together to add nuance or detail to the statement expressed in an Edge.
sources | [[RetrievalSource](#retrievalsource-)] | **REQUIRED**. A list of RetrievalSource objects that provide information about how a particular Information Resource served as a source from which the knowledge expressed in an Edge, or data used to generate this knowledge, was retrieved.

#### Qualifier [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1428:L1464)

An additional nuance attached to an assertion

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
qualifier_type_id | [CURIE](#curie-) | **REQUIRED**. CURIE for a Biolink 'qualifier' association slot, generally taken from Biolink association slots designated for this purpose (that is, association slots with names ending in 'qualifier') e.g. biolink:subject_aspect_qualifier,  biolink:subject_direction_qualifier, biolink:object_aspect_qualifier, etc. Such qualifiers are used to elaborate a second layer of meaning of a knowledge graph edge. Available qualifiers are edge properties in the Biolink Model (see https://biolink.github.io/biolink-model/docs/edge_properties.html) which have slot names with the suffix string 'qualifier'.
qualifier_value | `string` | **REQUIRED**. The value associated with the type of the qualifier, drawn from a set of controlled values by the type as specified in the Biolink model (e.g. 'expression' or 'abundance' for the qualifier type 'biolink:subject_aspect_qualifier', etc). The enumeration of qualifier values for a given qualifier type is generally going to be constrained by the category of edge (i.e. biolink:Association subtype) of the (Q)Edge.

#### QualifierConstraint [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1465:L1487)

Defines a query constraint based on the qualifier_types and qualifier_values of a set of Qualifiers attached to an edge. For example, it can constrain a "ChemicalX - affects - ?Gene" query to return only edges where ChemicalX specifically affects the 'expression' of the Gene, by constraining on the qualifier_type "biolink:object_aspect_qualifier" with a qualifier_value of "expression".

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
qualifier_set | [[Qualifier](#qualifier-)] | **REQUIRED**. A set of Qualifiers that serves to add nuance to a query, by constraining allowed values held by Qualifiers on queried Edges.

#### BiolinkEntity [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1488:L1498)

Compact URI (CURIE) for a Biolink class, biolink:NamedThing or a child thereof. The CURIE must use the prefix 'biolink:' followed by the PascalCase class name.

`string` (pattern: `^biolink:[A-Z][a-zA-Z]*$`)

##### Example

```json
"biolink:PhenotypicFeature"
```

#### BiolinkPredicate [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1499:L1510)

CURIE for a Biolink 'predicate' slot, taken from the Biolink slot ('is_a') hierarchy rooted in biolink:related_to (snake_case). This predicate defines the Biolink relationship between the subject and object nodes of a biolink:Association defining a knowledge graph edge.

`string` (pattern: `^biolink:[a-z][a-z_]*$`)

##### Example

```json
"biolink:interacts_with"
```

#### CURIE [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1511:L1520)

A Compact URI, consisting of a prefix and a reference separated by a colon, such as UniProtKB:P00738. Via an external context definition, the CURIE prefix and colon may be replaced by a URI prefix, such as http://identifiers.org/uniprot/, to form a full URI.

`string`
#### MetaKnowledgeGraph [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1521:L1547)

Knowledge-map representation of this TRAPI web service. The meta knowledge graph is composed of the union of most specific categories and predicates for each node and edge.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
nodes | Map[`string`, [MetaNode](#metanode-)] | **REQUIRED**. Collection of the most specific node categories provided by this TRAPI web service, indexed by Biolink class CURIEs. A node category is only exposed here if there is node for which that is the most specific category available.
edges | [[MetaEdge](#metaedge-)] | **REQUIRED**. List of the most specific edges/predicates provided by this TRAPI web service. A predicate is only exposed here if there is an edge for which the predicate is the most specific available.

#### MetaNode [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1548:L1571)

Description of a node category provided by this TRAPI web service.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
id_prefixes | [`string`] | **REQUIRED**. List of CURIE prefixes for the node category that this TRAPI web service understands and accepts on the input.
attributes | [[MetaAttribute](#metaattribute-)] | Node attributes provided by this TRAPI web service.

#### MetaEdge [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1572:L1634)

Edge in a meta knowledge map describing relationship between a subject Biolink class and an object Biolink class.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
subject | [BiolinkEntity](#biolinkentity-) | **REQUIRED**. Subject node category of this relationship edge.
predicate | [BiolinkPredicate](#biolinkpredicate-) | **REQUIRED**. Biolink relationship between the subject and object categories.
object | [BiolinkEntity](#biolinkentity-) | **REQUIRED**. Object node category of this relationship edge.
knowledge_types | [`string`] | A list of knowledge_types that are supported by the service. If the knowledge_types is null, this means that only 'lookup' is supported. Currently allowed values are 'lookup' or 'inferred'.
attributes | [[MetaAttribute](#metaattribute-)] | Edge attributes provided by this TRAPI web service.
qualifiers | [[MetaQualifier](#metaqualifier-)] | Qualifiers that are possible to be found on this edge type.
association | [BiolinkEntity](#biolinkentity-) | The Biolink association type (entity) that this edge represents. Associations are classes in Biolink that represent a relationship between two entities. For example, the association 'gene interacts with gene' is represented by the Biolink class, 'biolink:GeneToGeneAssociation'.  If association is filled out, then the testing harness can help validate that the qualifiers are being used correctly.

#### MetaQualifier [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1635:L1652)


##### Fixed Fields

Field Name | Type | Description
---|:---:|---
qualifier_type_id | [CURIE](#curie-) | **REQUIRED**. The CURIE of the qualifier type.
applicable_values | [`string`] | The list of values that are possible for this qualifier.

#### MetaAttribute [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1653:L1690)


##### Fixed Fields

Field Name | Type | Description
---|:---:|---
attribute_type_id | [CURIE](#curie-) | **REQUIRED**. Type of an attribute provided by this TRAPI web service (preferably the CURIE of a Biolink association slot)
attribute_source | `string` | Source of an attribute provided by this TRAPI web service.
original_attribute_names | [`string`] | Names of an the attribute as provided by the source.
constraint_use | `boolean` | Indicates whether this attribute can be used as a query constraint.
constraint_name | `string` | Human-readable name or label for the constraint concept. Required whenever constraint_use is true.

#### AttributeConstraint [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1691:L1782)

Generic query constraint for a query node or query edge

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
id | [CURIE](#curie-) | **REQUIRED**. CURIE of the concept being constrained. For properties defined by the Biolink model this SHOULD be a biolink CURIE. otherwise, if possible, from the EDAM ontology. If a suitable CURIE does not exist, enter a descriptive phrase here and submit the new type for consideration by the appropriate authority.
name | `string` | **REQUIRED**. Human-readable name or label for the constraint concept. If appropriate, it SHOULD be the term name of the CURIE used as the 'id'. This is redundant but required for human readability.
not | `boolean` | 
operator | `string` | **REQUIRED**. Relationship between the database value and the constraint value for the specified id. The operators ==, >, and < mean is equal to, is greater than, and is less than, respectively. The 'matches' operator indicates that the value is a regular expression to be evaluated. If value is a list type, then at least one evaluation must be true (equivalent to OR). This means that the == operator with a list acts like a SQL 'IN' clause. If the value of the compared attribute is a list, then comparisons are performed between each of the constraint values and each of the attribute values, and any one true evaluation counts as an overall true (e.g., [1,2,3] == [6,7,2] is true). The == operator is therefore a broad interpretation of inclusion. The '===' operator requires that the constraint value and the attribute value be the same data type, length, content, and order (e.g. only [1,2,3] === [1,2,3]). The 'not' property negates the operator such that not and == means 'not equal to' (or 'not in' for a list), and not > means <=, and not < means >=, not matches means does not match, and not === means the match between the constraint and attribute values are not exact. The '==' operator SHOULD NOT be used in a manner that describes an "is a" subclass relationship for the parent QNode.
value | any | **REQUIRED**. Value of the attribute. May be any data type, including a list. If the value is a list and there are multiple items, at least one comparison must be true (equivalent to OR) unless the '===' operator is used. If 'value' is of data type 'object', the keys of the object MAY be treated as a list. A 'list' data type paired with the '>' or '<' operators will encode extraneous comparisons, but this is permitted as it is in SQL and other languages.
unit_id | any | CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) should be used if possible. The unit_id MUST be provided for (lists of) numerical values that correspond to a quantity that has units.
unit_name | any | Term name that is associated with the CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) SHOULD be used if possible. This property SHOULD be provided if a unit_id is provided. This is redundant but recommended for human readability.

#### RetrievalSource [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1783:L1839)

Provides information about how a particular InformationResource served as a source from which knowledge expressed in an Edge, or data used to generate this knowledge, was retrieved.

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
resource_id | [CURIE](#curie-) | **REQUIRED**. The CURIE for an Information Resource that served as a source of knowledge expressed in an Edge, or a source of data used to generate this knowledge.
resource_role | [ResourceRoleEnum](#resourceroleenum-) | **REQUIRED**. The role played by the InformationResource in serving as a source for an Edge. Note that a given Edge should have one and only one 'primary' source, and may have any number of 'aggregator' or 'supporting data' sources.
upstream_resource_ids | [[CURIE](#curie-)] | An upstream InformationResource from which the resource being described directly retrieved a record of the knowledge expressed in the Edge, or data used to generate this knowledge. This is an array because there are cases where a merged Edge holds knowledge that was retrieved from multiple sources. e.g. an Edge provided by the ARAGORN ARA can expressing knowledge it retrieved from both the automat-mychem-info and molepro KPs, which both provided it with records of this single fact.
source_record_urls | [`string`] | A URL linking to a specific web page or document provided by the  source, that contains a record of the knowledge expressed in the  Edge. If the knowledge is contained in more than one web page on  an Information Resource's site, urls MAY be provided for each.  For example, Therapeutic Targets Database (TTD) has separate web  pages for 'Imatinib' and its protein target KIT, both of which hold  the claim that 'the KIT protein is a therapeutic target for Imatinib'.         

#### ResourceRoleEnum [?](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1840:L1851)

The role played by the InformationResource in serving as a source for an Edge. Note that a given Edge should have one and only one 'primary' source, and may have any number of 'aggregator' or 'supporting data' sources.  This enumeration is found in Biolink Model, but is repeated here for convenience.

`string`

one of:
* primary_knowledge_source
* aggregator_knowledge_source
* supporting_data_source




================================================
FILE: docs/reference_template.md
================================================
{%- macro schema_summary(schema) -%}
    {%- if '$ref' in schema -%}
        {%- set ref_name=schema['$ref'].split('/')[3] -%}
        [{{ ref_name }}](#{{ ref_name|lower }}-)
    {%- elif schema['type'] == 'array' -%}
        [{{ schema_summary(schema['items']) }}]
    {%- elif 'oneOf' in schema -%}
        {%- for subschema in schema['oneOf'] -%}
            {{ schema_summary(subschema) }}
            {%- if not loop.last %} \| {% endif -%}
        {%- endfor -%}
    {%- elif 'additionalProperties' in schema -%}
        Map[`string`, {{ schema_summary(schema['additionalProperties']) }}]
    {%- elif 'type' in schema -%}
        `{{ schema['type'] }}`
    {%- else -%}
        any
    {%- endif -%}
{%- endmacro -%}

# Translator Reasoner API

## Components

{% for name, schema in schemas.items() -%}{%- if schema is mapping -%}
#### {{ name }} [â†—](https://github.com/NCATSTranslator/ReasonerAPI/blob/{{ sha }}/TranslatorReasonerAPI.yaml#L{{ schema._start }}:L{{ schema._end }})

{% if 'description' in schema -%}
{{ schema.description }}
{% endif -%}
{% if schema.type != 'object' %}
`{{ schema.type }}`
{%- if schema.type == 'string' and 'pattern' in schema %} (pattern: `{{ schema.pattern }}`)
{%- endif %}
{% endif -%}
{% if 'enum' in schema %}
one of:
{% for option in schema.enum -%}
* {{ option }}
{% endfor %}
{% endif -%}
{%- if schema.type == 'object' %}
##### Fixed Fields

Field Name | Type | Description
---|:---:|---
{% for prop_name, prop_schema in schema['properties'].items() -%}{%- if prop_schema is mapping -%}
    {{ prop_name }} | {{ schema_summary(prop_schema) }} | {% if 'required' in schema and prop_name in schema.required %}**REQUIRED**. {% endif -%}
    {{ prop_schema.description }}
{% endif %}{%- endfor %}
{% endif -%}
{%- if 'example' in schema %}
##### Example

```json
{{ schema.example|tojson(indent=4) }}
```

{% endif -%}
{%- endif -%}{%- endfor -%}



================================================
FILE: docs/requirements.txt
================================================
jinja2
pyyaml


================================================
FILE: ImplementationGuidance/DataExamples/causes_predicate_vs_qualifier.json
================================================
{
  "query_graph": {
    "nodes": {
      "n0": {
        "categories": [
          "biolink:ChemicalEntity"
        ]
      },
      "n1": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "HGNC:3467"
        ]
      }
    },
    "edges": {
      "e01": {
        "subject": "n0",
        "object": "n1",
        "predicates": [
          "biolink:affects"
        ],
        "qualifier_constraints": [
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "activity"
              },
              {
                "qualifier_type_id": "biolink:object_modifier_qualifier",
                "qualifier_value": "increased"
              },
              {
                "qualifier_type_id": "biolink:qualified_predicate",
                "qualifier_value": "biolink:causes"
              }
            ]
          }
        ]
      }
    }
  },
  "knowledge_graph": {
    "nodes": {
      "PUBCHEM.COMPOUND:6623": {
        "categories": [
          "biolink:ChemicalEntity"
        ],
        "name": "Bisphenol A"
      },
      "HGNC:3467": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "EGRB2"
      }
    },
    "edges": {
      "x17770": {
        "predicate": "biolink:affects",
        "subject": "PUBCHEM.COMPOUND:6623",
        "object": "HGNC:3467",
        "qualifiers": [
          {
            "qualifier_type_id": "biolink:object_aspect_qualifier",
            "qualifier_value": "activity"
          },
          {
            "qualifier_type_id": "biolink:object_modifier_qualifier",
            "qualifier_value": "increased"
          },
          {
            "qualifier_type_id": "biolink:qualified_predicate",
            "qualifier_value": "biolink:causes"
          },
          {
            "qualifier_type_id": "biolink:causal_mechanism_qualifier",
            "qualifier_value": "binding"
          }
        ]
      }
    },
    "results": [
      {
        "node_bindings": {
          "n0": [
            {
              "id": "PUBCHEM.COMPOUND:6623"
            }
          ],
          "n1": [
            {
              "id": "HGNC:3467"
            }
          ]
        },
        "edge_bindings": {
          "e01": [
            {
              "id": "x17770"
            }
          ]
        }
      }
    ]
  }
}



================================================
FILE: ImplementationGuidance/DataExamples/complex_gocam_qualifiers.json
================================================
{
  "query_graph": {
    "nodes": {
      "n0": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "FB:FBgn0003205"
        ]
      },
      "n1": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "FB:FBgn0003079"
        ]
      }
    },
    "edges": {
      "e01": {
        "subject": "n0",
        "object": "n1",
        "predicates": [
          "biolink:regulates"
        ],
        "qualifier_constraints": [
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:subject_aspect_qualifier",
                "qualifier_value": "GO:0043539"
              },
              {
                "qualifier_type_id": "biolink:subject_context_qualifier",
                "qualifier_value": "GO:0005886"
              },
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "GO:0004708"
              },
              {
                "qualifier_type_id": "biolink:object_context_qualifier",
                "qualifier_value": "GO:0005737"
              },
              {
                "qualifier_type_id": "biolink:object_direction_qualifier",
                "qualifier_value": "increased"
              },
              {
                "qualifier_type_id": "biolink:pathway_context_qualifier",
                "qualifier_value": "GO:0038134"
              }
            ]
          }
        ]
      }
    }
  },
  "knowledge_graph": {
    "nodes": {
      "FB:FBgn0003205": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "Ras85D"
      },
      "FB:FBgn0003079": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "Raf"
      }
    },
    "edges": {
      "x17770": {
        "predicate": "biolink:regulates",
        "subject": "FB:FBgn0003205",
        "object": "FB:FBgn0003079",
        "qualifiers": [
          {
            "qualifier_type_id": "biolink:subject_aspect_qualifier",
            "qualifier_value": "GO:0043539"
          },
          {
            "qualifier_type_id": "biolink:subject_context_qualifier",
            "qualifier_value": "GO:0005886"
          },
          {
            "qualifier_type_id": "biolink:object_aspect_qualifier",
            "qualifier_value": "GO:0004708"
          },
          {
            "qualifier_type_id": "biolink:object_context_qualifier",
            "qualifier_value": "GO:0005737"
          },
          {
            "qualifier_type_id": "biolink:object_direction_qualifier",
            "qualifier_value": "increased"
          },
          {
            "qualifier_type_id": "biolink:pathway_context_qualifier",
            "qualifier_value": "GO:0038134"
          }
        ]
      }
    }
  },
  "results": [
    {
      "node_bindings": {
        "n0": [
          {
            "id": "FB:FBgn0003205"
          }
        ],
        "n1": [
          {
            "id": "FB:FBgn0003079"
          }
        ]
      },
      "edge_bindings": {
        "e01": [
          {
            "id": "x17770"
          }
        ]
      }
    }
  ]
}



================================================
FILE: ImplementationGuidance/DataExamples/localization_or_transport.json
================================================
{
  "query_graph": {
    "nodes": {
      "n0": {
        "categories": [
          "biolink:ChemicalEntity"
        ]
      },
      "n1": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "HGNC:3467"
        ]
      }
    },
    "edges": {
      "e01": {
        "subject": "n0",
        "object": "n1",
        "predicates": [
          "biolink:affects"
        ],
        "qualifier_constraints": [
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "localization"
              }
            ]
          },
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "transport"
              }
            ]
          }
        ]
      }
    }
  },
  "knowledge_graph": {
    "nodes": {
      "PUBCHEM.COMPOUND:6623": {
        "categories": [
          "biolink:ChemicalEntity"
        ],
        "name": "Bisphenol A"
      },
      "HGNC:3467": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "EGRB2"
      },
      "PUBCHEM.COMPOUND:6625": {
        "categories": [
          "biolink:ChemicalEntity"
        ],
        "name": "C03893"
      }
    },
    "edges": {
      "x17770": {
        "predicate": "biolink:affects",
        "subject": "PUBCHEM.COMPOUND:6623",
        "object": "HGNC:3467",
        "qualifiers": [
          {
            "qualifier_type_id": "biolink:object_aspect_qualifier",
            "qualifier_value": "localization"
          }
        ]
      },
      "x17771": {
        "predicate": "biolink:affects",
        "subject": "PUBCHEM.COMPOUND:6625",
        "object": "HGNC:3467",
        "qualifiers": [
          {
            "qualifier_type_id": "biolink:object_aspect_qualifier",
            "qualifier_value": "transport"
          }
        ]
      }
    }
  },
  "results": [
    {
      "node_bindings": {
        "n0": [
          {
            "id": "PUBCHEM.COMPOUND:6623"
          },
          {
            "id": "PUBCHEM.COMPOUND:6625"
          }
        ],
        "n1": [
          {
            "id": "HGNC:3467"
          }
        ]
      },
      "edge_bindings": {
        "e01": [
          {
            "id": "x17770"
          },
          {
            "id": "x17771"
          }
        ]
      }
    }
  ]
}



================================================
FILE: ImplementationGuidance/DataExamples/metaedge_with_qualifiers.json
================================================
{
  "nodes": {
    "biolink:MolecularActivity": {
      "id_prefixes": [
        "RHEA",
        "REACT",
        "GO",
        "UMLS"
      ]
    },
    "biolink:SmallMolecule": {
      "id_prefixes": [
        "CHEBI",
        "CHEMBL.COMPOUND",
        "UMLS",
        "UNII",
        "PUBCHEM.COMPOUND",
        "DRUGBANK",
        "MESH",
        "KEGG.COMPOUND",
        "HMDB",
        "CAS",
        "KEGG.DRUG"
      ]
    }
  },
  "edges": [
    {
      "subject": "biolink:ChemicalEntity",
      "predicate": "biolink:affects",
      "object": "biolink:Gene",
      "knowledge_types": [
        "lookup"
      ],
      "association": "biolink:ChemicalToGeneAssociation",
      "qualifiers": [
        {
          "qualifier_type_id": "biolink:subject_aspect_qualifier",
          "applicable_values": [
            "abundance",
            "degradation"
          ]
        },
        {
          "qualifier_type_id": "biolink:object_aspect_qualifier",
          "applicable_values": [
            "expression",
            "abundance",
            "activity"
          ]
        },
        {
          "qualifier_type_id": "biolink:qualified_predicate",
          "applicable_values": [
            "biolink:causes"
          ]
        }
      ]
    }
  ]
}



================================================
FILE: ImplementationGuidance/DataExamples/object_qualifiers.json
================================================
{
  "query_graph": {
    "nodes": {
      "n0": {
        "categories": [
          "biolink:ChemicalEntity"
        ]
      },
      "n1": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "HGNC:3467"
        ]
      }
    },
    "edges": {
      "e01": {
        "subject": "n0",
        "object": "n1",
        "predicates": [
          "biolink:affects"
        ],
        "qualifier_constraints": [
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "degradation"
              },
              {
                "qualifier_type_id": "biolink:object_direction_qualifier",
                "qualifier_value": "decreased"
              },
              {
                "qualifier_type_id": "biolink:qualified_predicate",
                "qualifier_value": "biolink:causes"
              }
            ]
          }
        ]
      }
    }
  },
  "knowledge_graph": {
    "nodes": {
      "PUBCHEM.COMPOUND:6623": {
        "categories": [
          "biolink:ChemicalEntity"
        ],
        "name": "Bisphenol A"
      },
      "HGNC:3467": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "ESR1"
      }
    },
    "edges": {
      "x17770": {
        "predicate": "biolink:affects",
        "subject": "PUBCHEM.COMPOUND:6623",
        "object": "HGNC:3467",
        "qualifiers": [
          {
            "qualifier_type_id": "biolink:object_aspect_qualifier",
            "qualifier_value": "degradation"
          },
          {
            "qualifier_type_id": "biolink:object_direction_qualifier",
            "qualifier_value": "decreased"
          },
          {
            "qualifier_type_id": "biolink:qualified_predicate",
            "qualifier_value": "biolink:causes"
          }
        ]
      }
    }
  },
  "results": [
    {
      "node_bindings": {
        "n0": [
          {
            "id": "PUBCHEM.COMPOUND:6623"
          }
        ],
        "n1": [
          {
            "id": "HGNC:3467"
          }
        ]
      },
      "edge_bindings": {
        "e01": [
          {
            "id": "x17770"
          }
        ]
      }
    }
  ]
}



================================================
FILE: ImplementationGuidance/DataExamples/simple.json
================================================
{
    "query_graph": {
        "nodes": {
            "n0": {
                "categories": ["biolink:Disease"],
                "ids": ["MONDO:0005737"]
            },
            "n1": {
                "categories": ["biolink:Gene"]
            }
        },
        "edges": {
            "e01": {
                "subject": "n0",
                "object": "n1"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "MONDO:0005737": {
                "categories": ["biolink:Disease"],
                "name": "Ebola hemorrhagic fever"
            },
            "HGNC:17770": {
                "categories": ["biolink:Gene"],
                "name": "RALGAPA1"
            },
            "HGNC:13236": {
                "categories": ["biolink:Gene"],
                "name": "URI1"
            }
        },
        "edges": {
            "x17770": {
                "predicate": "biolink:related_to",
                "subject": "MONDO:0005737",
                "object": "HGNC:17770"
            },
            "x13236": {
                "predicate": "biolink:related_to",
                "subject": "MONDO:0005737",
                "object": "HGNC:13236"
            }
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "MONDO:0005737"
                    }
                ],
                "n1": [
                    {
                        "id": "HGNC:17770"
                    }
                ]
            },
            "edge_bindings": {
                "e01": [
                    {
                        "id": "x17770"
                    }
                ]
            }
        },
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "MONDO:0005737"
                    }
                ],
                "n1": [
                    {
                        "id": "HGNC:13236"
                    }
                ]
            },
            "edge_bindings": {
                "e01": [
                    {
                        "id": "x13236"
                    }
                ]
            }
        }
    ]
}



================================================
FILE: ImplementationGuidance/DataExamples/subject_and_object_qualifiers.json
================================================
{
  "query_graph": {
    "nodes": {
      "n0": {
        "categories": [
          "biolink:ChemicalEntity"
        ]
      },
      "n1": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "ids": [
          "HGNC:286"
        ]
      }
    },
    "edges": {
      "e01": {
        "subject": "n0",
        "object": "n1",
        "predicates": [
          "biolink:affects"
        ],
        "qualifier_constraints": [
          {
            "qualifier_set": [
              {
                "qualifier_type_id": "biolink:subject_aspect_qualifier",
                "qualifier_value": "abundance"
              },
              {
                "qualifier_type_id": "biolink:subject_direction_qualifier",
                "qualifier_value": "decreased"
              },
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "expression"
              },
              {
                "qualifier_type_id": "biolink:object_direction_qualifier",
                "qualifier_value": "increased"
              },
              {
                "qualifier_type_id": "biolink:qualified_predicate",
                "qualifier_value": "biolink:causes"
              }
            ]
          }
        ]
      }
    }
  },
  "knowledge_graph": {
    "nodes": {
      "PUBCHEM.COMPOUND:6137": {
        "categories": [
          "biolink:ChemicalEntity"
        ],
        "name": "Methionine"
      },
      "HGNC:286": {
        "categories": [
          "biolink:GeneOrGeneProduct"
        ],
        "name": "ADRB2"
      }
    },
    "edges": {
      "x17770": {
        "predicate": "biolink:affects",
        "subject": "PUBCHEM.COMPOUND:6137",
        "object": "HGNC:286",
        "qualifiers": [
              {
                "qualifier_type_id": "biolink:subject_aspect_qualifier",
                "qualifier_value": "abundance"
              },
              {
                "qualifier_type_id": "biolink:subject_direction_qualifier",
                "qualifier_value": "decreased"
              },
              {
                "qualifier_type_id": "biolink:qualified_predicate",
                "qualifier_value": "biolink:causes"
              },
              {
                "qualifier_type_id": "biolink:object_aspect_qualifier",
                "qualifier_value": "expression"
              },
              {
                "qualifier_type_id": "biolink:object_direction_qualifier",
                "qualifier_value": "increased"
              }
        ]
      }
    }
  },
  "results": [
    {
      "node_bindings": {
        "n0": [
          {
            "id": "PUBCHEM.COMPOUND:6137"
          }
        ],
        "n1": [
          {
            "id": "HGNC:286"
          }
        ]
      },
      "edge_bindings": {
        "e01": [
          {
            "id": "x17770"
          }
        ]
      }
    }
  ]
}



================================================
FILE: ImplementationGuidance/MigrationGuides/MigrationAndImplementationGuide1-4.md
================================================
This guide is split into two major sections. The first section focuses on ARAs. The second section focuses on KPs.

# TRAPI 1.4 Migration and Implementation Guide - ARA

TRAPI 1.4 implements a few major breaking changes, and is therefore not backwards compatible with previous versions of TRAPI. This guide aims to provide instructions for how to transform a TRAPI 1.3 message into a TRAPI 1.4 message.

## TRAPI 1.3 Example Message

First we will start with an example TRAPI 1.3 message. For ease of reading, this message won't be exactly what a real message would look like. For instance, proper CURIEs will not be used in the example in many cases (like edge predicates) where they normally would be, instead being replaced by more easily readable words and names. CURIEs will be used in some instances where using the CURIE is pertinent to the change. The example presented is a representation of a message sent by an ARA to the ARS, however this can be fairly easily generalized.

```
"message": {
    "query_graph": {
        "nodes": {
            "n0": {
                "id": "diabetes"
            },
            "n1": {
                "categories": ["drug"]
            }
        },
        "edges": {
            "e0": {
                "predicates":["treats"],
                "subject": "n1",
                "object": "n0",
                "knowledge_type": "inferred"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "diabetes": {node_info},
            "metformin": {node_info},
            "hypoglycemia": {node_info}
            "extra_node": {node_info}
        },
        "edges": {
            "e01": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
            },
            "e02": {
                "subject": "diabetes",
                "object": "hypoglycemia",
                "predicate": "similar_to"
            },
            "e12": {
                "subject": "metformin",
                "object": hypoglycemia,
                "predicate": "contraindicated for"
            },
            "creative_edge" {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
            },
            "extra_edge0": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "co-occurs in literature with"
            },
            "extra_edge1": {
                "subject": "metformin",
                "object": "extra_node",
                "predicate": "related to"
            }
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ]
            },
            "edge_bindings": {
                "e0": [
                    {
                        "id": "e01"
                    }
                ]
            },
            "score": .4
        },
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ],
                "dummy_node": [
                    {
                        "id": "extra_node"
                    }
                ]
            },
            "edge_bindings": {
                "e0": [
                    {
                        "id": "e01"
                    }
                ],
                "dummy_edge0": [
                    {
                        "id": "extra_edge0"
                    }
                ],
                "dummy_edge1": [
                    {
                        "id": "extra_edge1"
                    }
                ]
            },
            "score": .6
        },
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ]
            },
            "edge_bindings": {
                "e0": [
                    {
                        "id": "creative_edge"
                    }
                ],
                "dummy_edge0": [
                    {
                        "id": "e02"
                    }
                ],
                "dummy_edge1": [
                    {
                        "id": "e12"
                    }
                ]
            },
            "score": .3
        }
    ]
}
```

This message is a creative mode query that asks which drug treats diabetes. Three results are returned in total. The first is a basic result that says metformin treats diabetes using a found edge. The second uses the same found edge, but also includes extra information in the form of literature co-occurrence edges and an extra node meant to help with scoring. The third uses a creative mode edge to determine that metformin treats diabetes.

The results are shown broken up for illustrative purposes to make this guide clearer, however that is not the true expected behavior. Instead, under the current universal binding scheme, the message would more likely look like this.

```
"message": {
    "query_graph": {
        "nodes": {
            "n0": {
                "id": "diabetes"
            },
            "n1": {
                "categories": ["drug"]
            }
        },
        "edges": {
            "e0": {
                "predicates":["treats],
                "subject": "n1",
                "object": "n0",
                "knowledge_type": "inferred"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "diabetes": {node_info},
            "metformin": {node_info},
            "hypoglycemia": {node_info}
            "extra_node": {node_info}
        },
        "edges": {
            "e01": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
            },
            "e02": {
                "subject": "diabetes",
                "object": "hypoglycemia",
                "predicate": "similar_to"
            },
            "e12": {
                "subject": "metformin",
                "object": hypoglycemia,
                "predicate": "contraindicated for"
            },
            "creative_edge" {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
            },
            "extra_edge0": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "co-occurs in literature with"
            },
            "extra_edge1": {
                "subject": "metformin",
                "object": "extra_node",
                "predicate": "related to"
            }
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ],
                "dummy_node": [
                    {
                        "id": "extra_node"
                    }
                ]
            },
            "edge_bindings": {
                "e0": [
                    {
                        "id": "e01"
                    },
                    {
                        "id": "creative_edge"
                    }
                ],
                "dummy_edge0": [
                    {
                        "id": "extra_edge0"
                    }
                ],
                "dummy_edge1": [
                    {
                        "id": "extra_edge1"
                    }
                ]
            },
            "score": .7
        }
    ]
}
```

## Migrating to TRAPI 1.4

Now we will go about transforming this message into a TRAPI 1.4 message, going step-by-step. Both the knowledge graph and the results will be modified, but first we create the auxiliary graphs.

### Auxiliary Graphs

There is now a top level property of a message named "auxiliary_graphs". Auxiliary graphs are graphs that provide support or evidence for both results and knowledge graph edges. They are composed of references to Edges in the knowledge graph.

- Auxiliary graphs SHOULD be referenced as support graphs on edges to provide the support for that edge, e.g. why that edge is inferred to be true
- Auxiliary graphs SHOULD be referenced as support graphs in Analyses to provide support for the analysis score. e.g. literature co-occurrence edges that do not really support the existence of other edges, but rather used to support scoring of a result, SHOULD be placed in an analysis support graph

We will now create the auxiliary graphs neccessary for our TRAPI 1.4 message. These use the same edge identifiers used in the knowledge graph of our TRAPI 1.3 message.

```
"auxiliary_graphs": {
    "a0": {
        "edges": [
            "e02",
            "e12"
        ]
    },
    "a1": {
        "edges": [
            "extra_edge0"
        ]
    },
    "a2": {
        "edges": [
            "extra_edge1"
        ]
    }
}
```

These auxiliary graphs each represent something different. "a0" represents the explanation for the creative edge found in our original message. "a1" is the graph of literature co-occurrence. "a2" is used for the extra node. Some of this is up to an ARA's discretion. For instance, if both "a1" and "a2" were produced by the same ARA, then that ARA may decide to create only a single auxiliary graph for both. Therefore, this is also a valid representation:

```
"auxiliary_graphs": {
    "a0": {
        "edges": [
            "e02",
            "e12"
        ]
    },
    "a1": {
        "edges": [
            "extra_edge0",
            "extra_edge1"
        ]
    }
}
```

We will be using the first "auxiliary_graphs" list going forward.

### Knowledge Graph

Most of the knowledge graph will remain the same in this example. Only one of the edges would be significantly changed. For readibility, we will only go over that edge.

```
"creative_edge": {
    "subject": "metformin",
    "object": "diabetes",
    "predicate": "treats",
    "attributes": [
        {
            "attribute_type_id": "biolink:support_graphs",
            "values": [
                "a0"
            ]
        }
    ]
}
```

The auxiliary graph that is being used as evidence for the creative edge is now attached to the attribute of the creative edge.

### Results

Results experience the largest refactor in TRAPI 1.4. From the three results presented before, we now make a single result.

```
"results": [
    {
        "node_bindings": {
            "n0": [
                {
                    "id": "diabetes"
                }
            ],
            "n1": [
                {
                    "id": "metformin"
                }
            ]
        },
        "analyses":[analysis objects]
    }
]
```

Notice that a result now has only two top-level properties: node bindings and analyses. Edge bindings and scores will now be included in the analyses, which is a list of analysis objects. We will go through creating an analysis object from each of the previous results.

Also notice that the node bindings lack any extra nodes. Only nodes that are present in the original query graph can be used in node bindings. The query graph may not be modified.

The first result has the most straighforward anaylsis block:

```
{
    "resource_id": "infores:ara0"
    "edge_bindings": {
        "e0": [
            {
                "id": "e01"
            }
        ]
    },
    "score": .4
}
```

From the second result, we construct this analysis:

```
{
    "resource_id": "infores:ara0"
    "edge_bindings": {
        "e0": [
            {
                "id": "e01"
            }
        ]
    }
    "support_graphs": [
        "a1",
        "a2"
    ],
    "score": .6
}
```

The auxiliary graphs that we constructed earlier are now being used as support for this analysis block, so therefore go into the "support_graphs" field of the analysis block.

Lastly, the third result generates this analysis:

```
{
    "resource_id": "infores:ara0"
    "edge_bindings": {
        "e0": [
            {
                "id": "creative_edge"
            }
        ]
    }
    "score": .3
}
```

Notice that the other components of the creative edge, the edges used to support it, are not included in the edge bindings. Instead, they have been included as evidence for the edge itself.

Those are all of the generated analysis blocks. As you can see, like node bindings, edge bindings can also only include edges found in the original query graph.

So the completed "analyses" list with these analysis blocks will look like this

```
"analyses": [
    {
        "resource_id": "infores:ara0"
        "edge_bindings": {
            "e0": [
                {
                    "id": "e01"
                }
            ]
        },
        "score": .4
    },
    {
        "resource_id": "infores:ara0"
        "edge_bindings": {
            "e0": [
                {
                    "id": "e01"
                }
            ]
        }
        "support_graphs": [
            "a1",
            "a2"
        ],
        "score": .6
    },
    {
        "resource_id": "infores:ara0"
        "edge_bindings": {
            "e0": [
                {
                    "id": "creative_edge"
                }
            ]
        }
        "score": .3
    }
]
```

However, an ARA also has discretion in the construction of the analysis blocks as well. All three of those analysis blocks can be combined into a single analysis instead. If that decision is made, then the results would look like this instead.

```
"results": [
    {
        "node_bindings": {
            "n0": [
                {
                 "id": "diabetes"
                }
            ],
            "n1": [
                {
                    "id": "metformin"
                }
            ]
        },
        "analyses":[
            {
                "resource_id": "infores:ara0"
                "edge_bindings": {
                    "e0": [
                        {
                            "id": "e01"
                        },
                        {
                            "id": "creative_edge"
                        }
                    ]
                },
                "support_graphs": [
                    "a1",
                    "a2"
                ]
                "score": .7
            },
        ]
    }
]
```

## TRAPI 1.4 Example Message

Finally, we can put all of it back together, to show the full message.

```
"message": {
    "query_graph": {
        "nodes": {
            "n0": {
                "id": "diabetes"
            },
            "n1": {
                "categories": ["drug"]
            }
        },
        "edges": {
            "e0": {
                "predicates":["treats],
                "subject": "n1",
                "object": "n0",
                "knowledge_type": "inferred"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "diabetes": {node_info},
            "metformin": {node_info},
            "hypoglycemia": {node_info}
            "extra_node": {node_info}
        },
        "edges": {
            "e01": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
            },
            "e02": {
                "subject": "diabetes",
                "object": "hypoglycemia",
                "predicate": "similar_to"
            },
            "e12": {
                "subject": "metformin",
                "object": hypoglycemia,
                "predicate": "contraindicated for"
            },
            "creative_edge": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
                "attributes": [
                    {
                        "attribute_type_id": "biolink:support_graphs",
                        "values": [
                            "a0"
                        ]
                    }
                ]
            },
            "extra_edge0": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "co-occurs in literature with"
            },
            "extra_edge1": {
                "subject": "metformin",
                "object": "extra_node",
                "predicate": "related to"
            }
        }
    },
    "auxiliary_graphs": {
        "a0": {
            "edges": [
                "e02",
                "e12"
            ]
        },
        "a1": {
            "edges": [
                "extra_edge0"
            ]
        },
        "a2": {
            "edges" [
                "extra_edge1"
            ]
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ]
            },
            "analyses":[
                {
                    "resource_id": "infores:ara0"
                    "edge_bindings": {
                        "e0": [
                            {
                                "id": "e01"
                            },
                            {
                                "id": "creative_edge"
                            }
                        ]
                    },
                    "support_graphs": [
                        "a1",
                        "a2"
                    ]
                    "score": .7
                },
            ]
        }
    ]
}
```

# TRAPI 1.4 Migration and Implementation Guide - KP

The process for KP's is much simpler. However, in this section we will also go over the changes to source retrieval provenance as well. Although this change does affect ARA's as well, the effect is much greater for KP's.

## TRAPI 1.3 Example Message

We will use a much simpler example message for the KP guide.

```
"message": {
    "query_graph": {
        "nodes": {
            "n0": {
                "id": "diabetes"
            },
            "n1": {
                "categories": ["drug"]
            }
        },
        "edges": {
            "e0": {
                "predicates":["treats],
                "subject": "n1",
                "object": "n0"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "diabetes": {node_info},
            "metformin": {node_info}
        },
        "edges": {
            "e01": {
                "subject": "metformin",
                "object": "diabetes",
                "predicate": "treats",
                "attributes": [
                    {
                        "attribute_type_id": "biolink:primary_knowledge_source",
                        "value": ["infores:ks0"],
                        "value_type_id": "biolink:InformationResource",
                        "attribute_source": "infores:kp0"
                    },
                    {
                        "attribute_type_id": "biolink:aggregator_knowledge_source",
                        "value": ["infores:ks1"],
                        "value_type_id": "biolink:InformationResource",
                        "attribute_source": "infores:kp0"
                    },
                    {
                        "attribute_type_id": "biolink:aggregator_knowledge_source",
                        "value": ["infores:kp0"],
                        "value_type_id": "biolink:InformationResource",
                        "attribute_source": "infores:kp0"
                    },
                ]
            }
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "diabetes"
                    }
                ],
                "n1": [
                    {
                        "id": "metformin"
                    }
                ]
            },
            "edge_bindings": {
                "e0": [
                    {
                        "id": "e01"
                    }
                ]
            }
        }
    ]
}
```

This KP response contains one edge. As illustrated, kp0 was able to obtain this edge from two seperate sources: ks0 and ks1. However, kp0 was able to determine that ks1 obtained this assertion from ks0, and this ks0 is the primary knowledge source.

## Migrating to TRAPI 1.4

Like the ARA guide, we will need to modify both the results and the knowledge graph for this example. However, we do not need to create any auxiliary graphs for this example, so that portion of the message may be excluded.

### Knowledge Graph

The main change here will be restructring the provenance information on the edge. This is done using the new "sources" field of an edge.

```
"e01": {
    "subject": "metformin",
    "object": "diabetes",
    "predicate": "treats",
    "attributes": []
    "sources":[
        {
            "resource_id": "infores:ks0",
            "resource_role": "primary_knowledge_source"
        },
        {
            "resource_id": "infores:ks1",
            "resource_role": "aggregator_knowledge_source",
            "upstream_resource_ids": [
                "infores:ks0"
            ]
        }
        {
            "resource_id": "infores:kp0",
            "resource_role": "aggregator_knowledge_source",
            "upstream_resource_ids": [
                "infores:ks0",
                "infores:ks1"
            ]
        }
    ]
}
```

Note that kp0 has two upstream resources listed, ks1 has one upstream resource listed, and ks0 has none.

### Results

Result generation for KP's is also relatively simple. In this case, we just migrate the edge bindings into the analysis section of the result.

```
{
    "node_bindings": {
        "n0": [
            {
                "id": "diabetes"
            }
        ],
        "n1": [
            {
                "id": "metformin"
            }
        ]
    },
    "analyses": [
        {
            "resource_id": "infores:kp0",
            "edge_bindings": {
                "e0": [
                    {
                        "id": "e01"
                    }
                ]
            }
        }
    ]
}
```

## TRAPI 1.4 Example Message

Now we can put these two sections back together to get the final message. The various JSON properties are given some credible final values not all present in the above text (but this allows this sample to validate properly using the reasoner-validator):

```
"message": {
    "query_graph": {
        "nodes": {
            "n0": {
                "ids": ["diabetes"]
            },
            "n1": {
                "categories": ["biolink:Drug"]
            }
        },
        "edges": {
            "e0": {
                "predicates":["biolink:treats"],
                "subject": "n1",
                "object": "n0"
            }
        }
    },
    "knowledge_graph": {
        "nodes": {
            "MONDO:0005148": {"name": "diabetes", "categories": ["biolink:Disease"]},
            "ncats.drug:9100L32L2N":  {"name": "metformin", "categories": ["biolink:Drug"]}
        },
        "edges": {
            "e01": {
                "subject": "ncats.drug:9100L32L2N",
                "object": "MONDO:0005148",
                "predicate": "biolink:treats",
                "attributes": [],
                "sources":[
                    {
                        "resource_id": "infores:ks0",
                        "resource_role": "primary_knowledge_source"
                    },
                    {
                        "resource_id": "infores:ks1",
                        "resource_role": "aggregator_knowledge_source",
                        "upstream_resource_ids": [
                            "infores:ks0"
                        ]
                    },
                    {
                        "resource_id": "infores:kp0",
                        "resource_role": "aggregator_knowledge_source",
                        "upstream_resource_ids": [
                            "infores:ks0",
                            "infores:ks1"
                        ]
                    }
                ]
            }
        }
    },
    "results": [
        {
            "node_bindings": {
                "n0": [
                    {
                        "id": "MONDO:0005148"
                    }
                ],
                "n1": [
                    {
                        "id": "ncats.drug:9100L32L2N"
                    }
                ]
            },
            "analyses": [
                {
                    "resource_id": "infores:kp0",
                    "edge_bindings": {
                        "e0": [
                            {
                                "id": "e01"
                            }
                        ]
                    }
                }
            ]
        }
    ]
}
```



================================================
FILE: ImplementationGuidance/Miscellaneous/examples_and_rules.md
================================================
## Biolink Qualifiers Examples

### Object qualifiers
_â€œBisphenol A results in decreased degradation of ESR1 proteinâ€_

```
subject: CHEBI:33216 # Bisphenol A
predicate: biolink:affects 
qualified_predicate: biolink:causes
object: NCBIGene:2099  # ESR1
object_aspect_qualifier: degradation
object_direction_qualifier: decreased
```
* [object_qualifiers.json](object_qualifiers.json)

Note: the predicate chosen should reflect the relationship between the subject and the object, and is not required
to be "affects".  For example, below we see a statement where the relationship between Bisphenol A and ESR1 is
not causal. 

_"Bisphenol A is associated with decreased degradation of ESR1 protein"_

```
subject: CHEBI:33216 # Bisphenol A
predicate: biolink:associated_with
object: NCBIGene:2099  # ESR1
object_aspect_qualifier: degradation
object_direction_qualifier: decreased
```


### Subject and object qualifiers
_â€œMethionine deficiency results in increased expression of ADRB2â€_

```
subject: "CHEBI:16811", # methionine
subject_aspect_qualifier: abundance
subject_direction_qualifier: decreased
predicate: biolink:affects 
qualified_predicate: biolink:causes
object: "NCBIGene:154" # ADRB2
object_aspect_qualifier: expression
object_direction_qualifier: increased
```

* [subject_and_object_qualifiers.json](subject_and_object_qualifiers.json)

_"Fenofibrate is an agonist of PPARA protein"_

```
subject: "CHEBI:5001"  # Fenofibrate
predicate: biolink:affects             
qualified_predicate: biolink:causes
object: "NCBIGene:5465"  # PPARA
object_aspect_qualifier: activity
object_direction_qualifier: increased
causal_mechanism_qualifier: agonism
```

### Complex statement

_"The protein ser/thr kinase activator activity of Ras85D in the plasma membrane directly positively regulates MAPKKK 
activity of Raf in the cytoplasm within the EGFR signaling pathway"_

```
subject: FB:FBgn0003205 # Dmel Ras85D
subject_aspect_qualifier: GO:0043539 # protein ser/thr kinase activator activity
subject_context_qualifier: GO:0005886 # plasma membrane
predicate: biolink:regulates   
qualified_predicate: biolink:causes
object: FB:FBgn0003079 # Dmel Raf
object_aspect_qualifier: GO:0004708 # MAPKKK activity
object_context_qualifier: GO:0005737 #cytoplasm
object_direction_qualifier: increased
pathway_context_qualifier: GO:0038134 # ERBB2-EGFR signaling pathway
```
Please note, pathway_context_qualifier is still under discussion in the Biolink Model. If you are trying to 
represent GO-CAMs, please contact the Biolink Model team for more information.

* [complex_gocam_qualifiers.json](complex_gocam_qualifiers.json)


### Querying for "_affects transport of_ *OR* _affects localization of_" with qualifiers instead of predicates.

_"What chemicals affect either the localization or the transport of ADRB2"_

* [localization_or_transport.json](localization_or_transport.json)


### When to use predicate=causes vs. qualified_predicate=causes

_"What chemicals cause increased activity of PPARA protein"_

* [causes_predicate_vs_qualifier.json](causes_predicate_vs_qualifier.json)

Note: in this example we need to convert the user's request for "causes" (predicate) to an "affects" predicate 
with a "causes" qualified_predicate.

### Qualifier Rules

These rules can not be enforced in the schema for TRAPI, but should be implemented in a validation layer.

1. __general rules__
   1. There MUST be only one of each type of qualifier in any edges.qualifier_constraints.qualifier_set
      1. There MUST be only one qualified_predicate for each set of qualifiers in a QualifierConstraint. 
      2. qualified_predicate is an optional qualifier. (see [localization_or_transport.json](localization_or_transport.json))
         1. Both the qualified_predicate and the predicate edge properties SHOULD be queried when a predicate is provided. 
         see [causes_predicate_vs_qualifier.json](causes_predicate_vs_qualifier.json)
   2. If a KP receives non-empty QEdge.qualifier_constraints, it MUST only return edges that satisfy the entire set of 
   qualifier_constraints. If a KP does not yet support QEdge.qualifier_constraints, it MUST return an empty response 
   because no matches are found.
      1. If a knowledge statement contains more qualifiers or differently typed qualifiers than those specified in
      edges.qualifier_constraints.qualifier_set in addition to the entire set of qualifier_constraints, the knowledge 
      statement MAY also be returned.
   3. Qualifier constraints should be treated as "or" constraints.
2. __qualifier_value__  
   1. is constrained by either: an enumeration in biolink, or an ontology term.  
      1. When an ontology term is used, the assumption is that annotations that use this term or any of its children 
      should be returned.
      2. When an enumerated value is used, the assumption is that annotations that use this enumerated value or any 
      of its children should be returned. 
         1. For example, if a query asks for "biolink:object_aspect_qualifier" = "abundance", 
         then, aspects matching any child of "abundance" should also be returned (if the other qualifiers used in this
         query are also satisfied).



================================================
FILE: ImplementationGuidance/Specifications/knowledge_level_agent_type_specification.md
================================================
# A TRAPI Specification for Knowledge Level and Agent Type Edge Annotations

## Overview
â€˜At-a-Glanceâ€™ (AAG) provenance information allow users to make a first-pass assessment of the strength, relevance, and utility of a given Edge or Result. They are supported by five specific edge properties defined in the Biolink Model:
- agent_type
- knowledge_level
- evidence_types (name t.b.d)
- method_types (name t.b.d)
- score

These properties are complemented by a larger model that is being developed to support a more detailed representation of evidence and provenance metadata, and will be documented elsewhere.
   
The scope of this initial specification covers only **Agent Type** and **Knowledge Level** metadata - which describes the type of knowledge expressed in an edge based on type of agent that originally generated a statement of knowledge encoded in an Edge, and the level of knowledge expressed in an Edge. It is complemented by a [Supplemental Guidance document](https://docs.google.com/document/d/140dtM5CjWM97JiBRdAmDT-9IKqHoOj-xbE_5TWkdYqg/edit) that provides detailed examples implementation support.

## Biolink properties and enumerations
Biolink defines hte following properties and enumerations for classifying agent type and knowledge level, which are used to annotate individual edges in knowledge graphs. 

### Agent Type
**Biolink Edge Property**:
   - `agent_type`: describes the high-level category of agent that originally generated a statement of knowledge or other type of information. Permissible values are provided by the **biolink:AgentTypeEnum** enumeration, as defined below:

**Permissible Values**:

   - `manual_agent`: a human agent is responsible for generating the knowledge expressed in the Edge.  The human may utilize computationally generated information as evidence for the resulting knowledge, but the human is the one who ultimately generates this knowledge.
    - `automated_agent`: an automated agent, typically a software program or tool, is responsible for generating the knowledge expressed in the Edge. Human contribution to the knowledge creation process  ends with the definition and coding of algorithms or analysis pipelines that get  executed by the automated agent.
        - `data_analysis_pipeline`:  an automated agent that executes an analysis workflow over data and reports results in an Edge. These typically  report statistical associations/correlations between variables in the input data.
        - `computational_model`: an automated agent that generates knowledge (typically predictions) based on rules/logic explicitly encoded in an algorithm (e.g. heuristic models, supervised classifiers), or  learned from patterns observed in data (e.g. ML models, unsupervised classifiers).
        - `text_mining_agent`:  an automated agent that uses Natural Language Processing to recognize concepts and/or relationships in text, and generates Edges relating these concepts with formally encoded semantics.
        - `image_processing_agent`: an automated agent that processes images to generate Edges reporting knowledge  derived from the image and/or expressed in text the image depicts (e.g. via OCR).
   - ` manual_validation_of_ automated_agent`: a human agent reviews and validates/approves the veracity of knowledge that is initially generated by an automated agent.
   - `not_provided`:  the agent type is not provided, typically because it cannot be determined from available information if the agent that generated the knowledge is manual or automated.

Note that this property indicates the type of agent who *produced a final statement of knowledge*, which is often different from the agent or agents who produced *information used as evidence* to support the generation of this knowledge. For example, if a human curator concludes that a particular gene variant causes a medical condition - based on their interpretation of information produced by computational modeling tools, automated statistical analyses, and robotic laboratory assay systems - the agent type for this statement is "manual_agent" despite all of the evidence being created by automated agents. But if any of these systems is programmed to generate knowledge statements directly and without human assistance, the statement would be attributed to an "automated_agent".

### Knowledge Level
**Biolink Edge Property**: 
- `knowledge_level`: describes the level of knowledge expressed in a statement, based on the reasoning or analysis methods used to generate the statement, or the scope or specificity of what the statement expresses to be true. Permissible values are defined in the **biolink:KnowledgeLevelEnum** enumeration:

**Permissible Values**:
   - `knowledge_assertion`: a statement of purported fact that is put forth by an agent as true, based on assessment of direct evidence. Assertions generally have a high confidence of being true based on the strength of evidence supporting them.
   - `logical_entailment`: a statement reporting a conclusion that follows logically from premises, which are typically well-established facts or knowledge assertions. (e.g. fingernail part of finger, finger part of hand â†’ fingernail part of hand)). Logical entailments are based on dedictive inference, and generally have a high degree of confidence when based on sound premises and inference logic. 
   - `prediction`: a statement of a possible fact based on more probabilistic (non-deductive) forms of reasoning over indirect forms of evidence, that lead to more speculative conclusions. Predictions often have a lower degree of confidence based on the indirect nature of their evidence and reasoning supporting them.
   - `statistical_association`: a statement that reports concepts representing variables in a dataset to be statistically associated in the context of a particular cohort or dataset (e.g. â€œMetformin Treatment (variable 1) is correlated with Diabetes Diagnosis (variable 2) in EHR dataset Xâ€). These associations are inherently true in that they simple report the results of some statistical analysis, but do not interpret these data to draw broader conclusions about general types in the domain of discourse.
   - `observation`: a statement reporting (and possibly quantifying) a phenomenon that was observed to occur - absent any analysis or interpretation that generates a statistical association or supports a broader conclusion or inference. Observation statements are also inherently true in that they simple report what an agent observed - without any interpretation or inference. 
   - `not_provided`: the knowledge level/type fora  statement is not provided, typically because it cannot be determined from available information.

NOTE that the notion of a 'level' of knowledge can in one sense relate to the strength of a statement - i.e. how confident we are that it says something true about our domain of discourse. Here, we can generally consider Knowledge Assertions to be stronger than Entailments to be stronger than Predictions. But in another sense, 'level' of knowledge can refer to the scope or specificity of what a statement expresses -  on a spectrum from context-specific results of a data analysis, to generalized assertions of knowledge or fact. Here, Statistical Associations and Observations represent more foundational statements that are only slightly removed from the data on which they are based (the former reporting the direct results of an analysis in terms of correlations between variables in the data, and the latter describing phenomena that were observed/reported to have occurred).

## Implementation Guidance

1. Knowledge Providers MUST report one and only one `agent type` on each Edge they return in a TRAPI message, using an Attribute object keyed on the `agent_type` property. The value of this property MUST come from the biolink:AgentTypeEnum.

       {
          "attribute_type_id": "biolink:agent_type",
          "value": "manual_agent",
          "attribute_source": "infores:molepro"
       }

2. Knowledge Providers MUST report one and only one `knowledge level` for each Edge returned in a TRAPI message, using an Attribute object keyed on the  `knowledge_level` property. The value MUST come from the biolink:KnowledgeLevelEnum.

       {   
       "attribute_type_id": "biolink:knowledge_level",
       "value": "knowledge_assertion",
       "attribute_source": "infores:molepro"
       }

3. The main challenge in applying this standard concerns selecting appropriate agent type and knowledge level terms for a given Edge. To assist KPs in this task, a [Supplemental Guidance document](https://docs.google.com/document/d/140dtM5CjWM97JiBRdAmDT-9IKqHoOj-xbE_5TWkdYqg/edit) provides additional implementation support beyond the base specification above. This includes clarification of key distinctions, tips for proper term selection, and a corpus of examples illustrating how agent type and knowledge level terms are applied to the diverse kinds of Edges provided in Translator knowledge graphs.




================================================
FILE: ImplementationGuidance/Specifications/pathfinder_query_specification.md
================================================
# Pathfinder Implementation Guide

This guide explains how to construct Pathfinder queries, outlines general interpretation rules, and describes how to 
interpret the results they return.

### Summary

* Pathfinder QueryGraph(s) do not contain edges, but instead contain Paths.
* Pathfinder Messages contain a QueryGraph, a KnowledgeGraph, AuxiliaryGraph, 
and Results.
* A Path can include constraints, but currently only `intermediate_categories` constraints.
* Paths are represented within AuxiliaryGraph and are expected to be linear (A-->B-->C-->D).  
* No branching Paths, or paths that skip nodes are allowed in AuxiliaryGraph.
* Paths have a distinct set of Nodes.

## General Message Structure

Pathfinder queries utilize the same general message structure as other query types. This means that a Message still
has a Query Graph, a Knowledge Graph, Results, and AuxiliaryGraphs.

## Query Graph

The QueryGraph is not a traditional QueryGraph, as it does not contain Edges. Instead, it contains Paths.

The QueryGraph still has a field for Nodes, as a traditional QueryGraph would, but instead of a field for Edges, it
has a field for Paths. This example shows a query that requests Paths connecting Crohn's
Disease with Parkinson's. All paths returned must connect these two nodes.

```
"query_graph": {
    "nodes": {
        "n0": {
            "ids": [
                "MONDO:0005011"
            ]
        },
        "n1": {
            "ids": [
                "MONDO:0005180"
            ]
        }
    },
    "paths": {
        "p0": {
            "subject": "n0",
            "object": "n1",
            "predicates": ["biolink:related_to"]
        }
    }
}
```

A Path can include constraints.  Currently, the only supported constraint type is `intermediate_categories`, 
which requires that all returned paths contain at least one node matching the specified category.
In the example below, the intermediate category constraint listed requires that paths have at least one `Gene`
node between them.

```
"query_graph": {
    "nodes": {
        "n0": {
            "ids": [
                "MONDO:0005011"
            ]
        },
        "n1": {
            "ids": [
                "MONDO:0005180"
            ]
        }
    },
    "paths": {
        "p0": {
            "subject": "n0",
            "object": "n1",
            "constraints": [
                {
                    "intermediate_categories": ["biolink:Gene"]
                }
            ]
        }
    }
}
```

* Note: The query graph should not have any edges.

## Knowledge and Auxiliary Graphs

The KnowledgeGraph in the message should have nodes and edges listed as usual. These correspond to whatever Nodes
and Edges are required to construct the paths between the subject and object nodes of the QPath. The Nodes
and Edges both follow the same rules as all other queries, although for the sake of brevity, the example below does not
contain all the required information typically found in a valid knowledge graph node and edge, such as knowledge
level or source.

```
"knowledge_graph": {
    "nodes": {
        "MONDO:0005011": {
            "categories": ["biolink:Disease"]
        },
        "MONDO:0005180": {
            "categories": ["biolink:Disease"]
        },
        "NCBIGene:120892": {
            "categories": ["biolink:Gene"]
        },
        "CL:0000540": {
            "categories": ["biolink:Cell"]
        }
    },
    "edges" {
        "e0": {
            "subject": "MONDO:0005011",
            "object": "NCBIGene:120892",
            "predicate": "biolink:condition_associated_with_gene"
        }
        "e1": {
            "subject": "NCBIGene:120892",
            "object": "MONDO:0005180",
            "predicate": "biolink:biomarker_for"
        },
        "e2": {
            "subject": "NCBIGene:120892",
            "object": "CL:0000540",
            "predicate": "biolink:located_in"
        },
        "e3": {
            "subject": "CL:0000540",
            "object": "MONDO:0005180",
            "predicate": "biolink:disrupted_by"
        },
        "e4": {
            "subject": "NCBIGene:120892",
            "object": "MONDO:0005180",
            "predicate": "biolink:gene_associated_with_condition"
        },
        "e5": {
            "subject": "MONDO:0005011",
            "object": "MONDO:0005180",
            "predicate": "biolink:associated_with"
        }
    }
}
```

Paths are represented within AuxiliaryGraphs. Each Path references edges from the KnowledgeGraph by key, stored in the
AuxiliaryGraph's `edges` field. These Edges are unordered; their sequence does not convey Path structure. Instead, the
Path must be reconstructed from the graph itself.

Paths are expected to be linearâ€”there should be no way to skip or bypass any node in the Path. However, parallel edges
between two nodes are allowed.

Using the Knowledge Graph above, we can construct the AuxiliaryGraphs shown in the example below:

```
"auxiliary_graphs": {
    "a0": {
        "edges": [
            "e0",
            "e1",
            "e4"
        ]
    },
    "a1": {
        "edges": [
            "e0",
            "e2",
            "e3"
        ]
    },
    "a2": {
        "edges": [
            "e5"
        ]
    },
}
```

Each generated Path has a distinct set of Nodes, and no AuxiliaryGraph contains branching Paths. For example, while `a0`
and `a1` share an intermediate node, they differ by at least one Node, so they are treated as separate Paths. Path `a0`
includes two parallel (but not branching) edges between a pair of nodes.

Path `a2` represents a direct lookup edge between Crohnâ€™s and Parkinsonâ€™s. If such a direct edge exists between the two
input nodes, it should be included as a valid path.

The Paths shown correspond to the unconstrained version of the initial query. Applying `intermediate_categories` 
constraints would yield a slightly different set of paths. As show below in the constrained version of the 
AuxiliaryGraphs, `a2` is  removed because it does not contain any `Gene` nodes. Therefore, it is not a valid Path 
for the constrained version of the query.

```
"auxiliary_graphs": {
    "a0": {
        "edges": [
            "e0",
            "e1",
            "e4"
        ]
    },
    "a1": {
        "edges": [
            "e0",
            "e2",
            "e3"
        ]
    }
}
```


## Results

Each individual Result is structured similarly, with NodeBindings and Analyses. Both input
nodes must be pinned, and therefor no unpinned nodes will exist in the QueryGraph.  This means there is only one result
for each query, contained within the Results field of the Message. This Result can have many Analyses, each one
corresponding to a different Path. This follows the same Result-merging rules used in other query types, where results
that contain the same nodes but different analyses are combined into a single result, with their analyses concatenated.

Each analysis no longer contains EdgeBindings, with no QueryGraph edges to bind to. Instead, the Analysis utilizes
PathBindings to bind to QPath. Each Path Binding binds an Auxiliary Graph by `id` to a QPath.
This is similar to how EdgeBindings bind a KnowledgeGraph Edge, by id, to a QueryGraph Edge.

```
"results": [
    {
        "node_bindings": {
            "n0": [
                {
                    "id": "MONDO:0005011",
                    "attributes": []
                }
            ],
            "n1": [
                {
                    "id": "MONDO:0005180",
                    "attributes": []
                }
            ]
        },
        "analyses": [
            {
                "path_bindings": {
                    "p0": [
                        {
                            "id": "a0"
                        }
                    ],
                },
                "score": .85
            },
            {
                "path_bindings": {
                    "p0": [
                        {
                            "id": "a1"
                        }
                    ],
                },
                "score": .7
            },
            {
                "path_bindings": {
                    "p0": [
                        {
                            "id": "a2"
                        }
                    ],
                },
                "score": .9
            }
        ]
    }
]
```

This is only valid for the unconstrained version of the query. The `intermediate_categories` constraint version
would look like this.

```
"results": [
    {
        "node_bindings": {
            "n0": [
                {
                    "id": "MONDO:0005011",
                    "attributes": []
                }
            ],
            "n1": [
                {
                    "id": "MONDO:0005180",
                    "attributes": []
                }
            ]
        },
        "analyses": [
            {
                "path_bindings": {
                    "p0": [
                        {
                            "id": "a0"
                        }
                    ],
                },
                "score": .85
            },
            {
                "path_bindings": {
                    "p0": [
                        {
                            "id": "a1"
                        }
                    ],
                },
                "score": .7
            }
        ]
    }
]
```

The Analysis containing the Path generated by the lookup Query is removed.

## Complete Message

The complete Message for the unconstrained query is shown below, with the QueryGraph, KnowledgeGraph, AuxiliaryGraphs
and Results all included. The constrained version is shown after that.

### Unconstrained

```
{
    "message" {
        "query_graph": {
            "nodes": {
                "n0": {
                    "ids": [
                        "MONDO:0005011"
                    ]
                },
                "n1": {
                    "ids": [
                        "MONDO:0005180"
                    ]
                }
            },
            "paths": {
                "p0": {
                    "subject": "n0",
                    "object": "n1",
                    "predicates": ["biolink:related_to"]
                }
            }
        },
        "knowledge_graph": {
            "nodes": {
                "MONDO:0005011": {
                    "categories": ["biolink:Disease"]
                },
                "MONDO:0005180": {
                    "categories": ["biolink:Disease"]
                },
                "NCBIGene:120892": {
                    "categories": ["biolink:Gene"]
                },
                "CL:0000540": {
                    "categories": ["biolink:Cell"]
                }
            },
            "edges" {
                "e0": {
                    "subject": "MONDO:0005011",
                    "object": "NCBIGene:120892",
                    "predicate": "biolink:condition_associated_with_gene"
                }
                "e1": {
                    "subject": "NCBIGene:120892",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:biomarker_for"
                },
                "e2": {
                    "subject": "NCBIGene:120892",
                    "object": "CL:0000540",
                    "predicate": "biolink:located_in"
                },
                "e3": {
                    "subject": "CL:0000540",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:disrupted_by"
                },
                "e4": {
                    "subject": "NCBIGene:120892",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:gene_associated_with_condition"
                },
                "e5": {
                    "subject": "MONDO:0005011",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:associated_with"
                }
            }
        },
        "auxiliary_graphs": {
            "a0": {
                "edges": [
                    "e0",
                    "e1",
                    "e4"
                ]
            },
            "a1": {
                "edges": [
                    "e0",
                    "e2",
                    "e3"
                ]
            },
            "a2": {
                "edges": [
                    "e5"
                ]
            },
        },
        "results": [
            {
                "node_bindings": {
                    "n0": [
                        {
                            "id": "MONDO:0005011",
                            "attributes": []
                        }
                    ],
                    "n1": [
                        {
                            "id": "MONDO:0005180",
                            "attributes": []
                        }
                    ]
                },
                "analyses": [
                    {
                        "path_bindings": {
                            "p0": [
                                {
                                    "id": "a0"
                                }
                            ],
                        },
                        "score": .85
                    },
                    {
                        "path_bindings": {
                            "p0": [
                                {
                                    "id": "a1"
                                }
                            ],
                        },
                        "score": .7
                    },
                    {
                        "path_bindings": {
                            "p0": [
                                {
                                    "id": "a2"
                                }
                            ],
                        },
                        "score": .9
                    }
                ]
            }
        ]
    }
}
```

### Constrained

```
{
    "message" {
        "query_graph": {
            "nodes": {
                "n0": {
                    "ids": [
                        "MONDO:0005011"
                    ]
                },
                "n1": {
                    "ids": [
                        "MONDO:0005180"
                    ]
                }
            },
            "paths": {
                "p0": {
                    "subject": "n0",
                    "object": "n1",
                    "constraints": [
                        {
                            "intermediate_categories": ["biolink:Gene"]
                        }
                    ]
                }
            }
        },
        "knowledge_graph": {
            "nodes": {
                "MONDO:0005011": {
                    "categories": ["biolink:Disease"]
                },
                "MONDO:0005180": {
                    "categories": ["biolink:Disease"]
                },
                "NCBIGene:120892": {
                    "categories": ["biolink:Gene"]
                },
                "CL:0000540": {
                    "categories": ["biolink:Cell"]
                }
            },
            "edges" {
                "e0": {
                    "subject": "MONDO:0005011",
                    "object": "NCBIGene:120892",
                    "predicate": "biolink:condition_associated_with_gene"
                }
                "e1": {
                    "subject": "NCBIGene:120892",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:biomarker_for"
                },
                "e2": {
                    "subject": "NCBIGene:120892",
                    "object": "CL:0000540",
                    "predicate": "biolink:located_in"
                },
                "e3": {
                    "subject": "CL:0000540",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:disrupted_by"
                },
                "e4": {
                    "subject": "NCBIGene:120892",
                    "object": "MONDO:0005180",
                    "predicate": "biolink:gene_associated_with_condition"
                }
            }
        },
        "auxiliary_graphs": {
            "a0": {
                "edges": [
                    "e0",
                    "e1",
                    "e4"
                ]
            },
            "a1": {
                "edges": [
                    "e0",
                    "e2",
                    "e3"
                ]
            }
        },
        "results": [
            {
                "node_bindings": {
                    "n0": [
                        {
                            "id": "MONDO:0005011",
                            "attributes": []
                        }
                    ],
                    "n1": [
                        {
                            "id": "MONDO:0005180",
                            "attributes": []
                        }
                    ]
                },
                "analyses": [
                    {
                        "path_bindings": {
                            "p0": [
                                {
                                    "id": "a0"
                                }
                            ],
                        },
                        "score": .85
                    },
                    {
                        "path_bindings": {
                            "p0": [
                                {
                                    "id": "a1"
                                }
                            ],
                        },
                        "score": .7
                    }
                ]
            }
        ]
    }
}
```


================================================
FILE: ImplementationGuidance/Specifications/query_specification.md
================================================
# QueryGraph Implementation Rules:

The following rules MUST be applied by implementers of TRAPI endpoints.
The rules are organized by class and property.

The terms MUST, SHOULD, MAY are used as defined in RFC 2119  https://tools.ietf.org/html/rfc2119 

## /asyncquery
- Knowledge Providers (KPs) MAY implement /asyncquery
- Autonomous Reasoning Agents (ARAs) SHOULD implement /asyncquery
- The /asyncquery endpoint SHOULD be left in an OpenAPI definition for a TRAPI endpoint even if
  if it is not implemented, since it is part of the TRAPI core schema
- Each TRAPI server MUST indicate with true or false if the /asyncquery endpoint is implemented
  by the server via the x-trapi asyncquery property as found in the TRAPI core schema template.

## QNode.ids
- MAY be null, or MAY be missing. The meaning is the same.
- MUST NOT be an empty array (#199)
- If more than one element is present, the elements MUST be treated in the sense of an "or" list.
  This effectively creates a simple batch query mechanism.
- The list SHOULD NOT be used by the client to provide equivalent CURIEs to the server
- If the server considers a subset of items in the list as equivalent CURIEs,
  the server SHOULD merge the subset into a single KnowledgeGraph Node

## QNode.categories
- MAY be null, or MAY be missing. The meaning is the same: matching Nodes may be any category
- If QNode.categories is [ 'biolink:NamedThing' ], it means matching Nodes may be any category
  (any descendent biolink category NamedThing)
- MUST NOT be an empty array (#199)
- If more than one element is present, the elements MUST be treated in the sense of an "or" list.
  Matching Nodes may be any of the listed QNode.categories
- Biolink category descendents do not need to be specified separately. Queries MUST automatically
  match descendents. (e.g. QNode.categories is [ 'biolink:BiologicalEntity' ], then the KP MUST return
  Nodes with category biolink:Protein and biolink:Disease if present)
- IF a QNode has non-null QNode.ids (CURIEs), the client SHOULD NOT provide QNode.categories, and
  the server SHOULD NOT require that categories are provided to function, and the server MAY provide
  different answers for different provided categories.

## QEdge.predicates
- MAY be null, or MAY be missing. The meaning is the same.
- MUST NOT be an empty array (#199)
- If more than one element is present, the elements MUST be treated in the sense of an "or" list.
  Matching Edges may be any of the listed QEdge.predicates. 
  This effectively creates a simple batch query mechanism where the response may contain multiple
  edges, where each one matches at least one of the specified QEdge.predicates.
- Biolink predicate descendents do not need to be specified separately. Queries MUST automatically
  match descendents. (e.g. QEdge.predicates is [ 'biolink:regulates' ], then the KP MUST return
  Edges with biolink:positively_regulates and biolink:negatively_regulates if present)

## QNode.xxxxx
- If a server receives a property on a QNode that it does not recognize, it SHOULD generate
  a warning and MAY continue processing.

## QEdge.xxxxx
- If a server receives a property on a QEdge that it does not recognize, it SHOULD generate
  a warning and MAY continue processing.

## QNode.constraints
- If a KP server receives any QNode.constraints, if it does not support all of them,
  it MUST immediately respond with an error Code "UnsupportedConstraint" and list
  all the specified constraint names that it does not support.
- If an ARA server receives any QNode.constraints, it MUST perform one of the following:
  - Relay all constraints to its KP(s) to satisfy
  - Withhold one or more constraints from its KP queries and satisfy those constraints itself
- An ARA server MUST ensure that all constraints are satisifed by either trusting its KPs to satisfy them
  or by performing the constraining itself. If the ARA cannot ensure this,
  it MUST immediately respond with an error Code "UnsupportedConstraint" and list all constraint
  names that it does not support.

## QEdge.qualifier_constraints
- If a KP server receives any QEdge.qualifier_constraints, it MUST only return qualified
  edges that are compatible with the constraints. It MUST NOT return any unqualified edges.
  If a KP does not yet support QEdge.qualifier_constraints, it MUST return an empty response
  because no matches are possible.
- If an ARA server receives any QEdge.qualifier_constraints, it MUST relay all
  QEdge.qualifier_constraints to its KP(s) to satisfy.

## info.x-trapi.batch_size_limit
- This batch size limit refers to the maximum length of any single QNode.ids list. The limit
  applies to the length of the list as supplied by the client, with the understanding that the server
  may further expand the list via descendant inference. If the descendant expansion becomes too
  large (e.g., if the client specified `MONDO:0000001: disease or disorder`), the server SHOULD
  return a runtime error gracefully.

## Specifying permitted and excluded KPs to an ARA
- The proper syntax for specifying or excluding specific KPs to consult to an ARA MUST be done
  via a `attribute_constraint` on a QEdge. The following is a complete Query example that disallows the
  use of SemMedDB:

```
{
  "message": {
    "query_graph": {
      "edges": {
        "e01": {
          "object": "n0",
          "subject": "n1",
          "predicates": [
            "biolink:entity_negatively_regulates_entity"
          ],
          "attribute_constraints": [
            {
              "id": "biolink:knowledge_source",
              "name": "knowledge source",
              "value": "infores:semmeddb",
              "not": true,
              "operator": "=="
            }
          ]
        }
      },
      "nodes": {
        "n0": {
          "ids": [
            "NCBIGene:23221"
          ],
          "categories": [
            "biolink:Gene"
          ]
        },
        "n1": {
          "categories": [
            "biolink:Gene"
          ]
        }
      }
    }
  }
}
```

A general "allowlist" SHOULD look like this:
```
      "attribute_constraints": [
        {
          "id": "biolink:knowledge_source",
          "name": "knowledge source",
          "value": [
            "infores:rtx-kg2",
            "infores:biothings-explorer",
          ],
          "operator": "=="
        }
      ],
```

(when the value is a list, the "==" operator works like a SQL "IN" clause, as clearly documented in the TRAPI yaml)

Here is what a general "denylist" should look like:
```
      "attribute_constraints": [
        {
          "id": "biolink:knowledge_source",
          "name": "knowledge source",
          "value": [
            "infores:rtx-kg2",
            "infores:biothings-explorer",
          ],
          "not": true,
          "operator": "=="
        }
      ],
```

(when the value is a list, the "==" operator combined with ' "not": true ' works like a SQL "NOT IN" clause, as clearly documented in the TRAPI yaml)




================================================
FILE: ImplementationGuidance/Specifications/retrieval_provenance_specification.md
================================================
# A TRAPI Attribute Specification for Source Retrieval Provenance

## Overview
"Source retrieval provenance" describes the set of Information Resources through which the knowledge expressed in an Edge was passed, through various retrieval and/or transform operations, on its way to its current serialized form. For example, the provenance of a Gene-Chemical Edge in a message sent to a Translator ARA (e.g. ARAGORN) might be traced through the Translator KP that provided it (e.g. MolePro), one or more intermediate aggregator resources (e.g. ChEMBL), and back to the resource that originally created/curated it (e.g. ClinicalTrials.org).

````
 ARAGORN  --retrieved_from-->   MolePro  --retrieved_from-->  ChEMBL  --retrieved_from-->  ClinicalTrials.gov
````
Note that source retrieval provenance concerns the **mechanical retrieval and transformation of data between web accessible information systems**. It does not trace the source of knowledge back to specific publications or data sets. And it is not concerned with the reasoning, inference or analysis activities that generate knowledge in the first place. These types of provenance are handled by a different set of properties in the EPC model (e.g. see the â€˜Supporting Publications Specificationâ€™ [here]([url](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/ImplementationGuidance/Specifications/supporting_publications_specification.md))).

## The Model
While the TRAPI schema uses the generic Attribute class for representing nearly all metadata about Edges in knowledge graphs, metadata about **source retrieval provenance** is an exception - given the need to efficently find and parse this information for purposes of edge merging and debugging.  A complete specification will be provided here soon.  This early draft provies a brief overview of the model itself, guidance and conventions for implementing the model, and a few data examples to follow.

The diagram below shows the classes and properties defined in the [TRAPI schema]([url](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/TranslatorReasonerAPI.yaml#L1107)) to support representation of source retrieval provenance metadata.

![image](https://github.com/NCATSTranslator/ReasonerAPI/assets/5184212/840b8061-2fe4-4e15-968f-97cd87de22ab)

The `Edge.sources` property contains one or more `RetrievalSource` objects - which capture information about how a particular InformationResource served as a source from which knowledge expressed in an Edge, or data used to generate this knowledge, was retrieved. 

| Property | Description |
| ------------- | ------------- |
| resource_id | (required) The CURIE for an InformationResource that served as a source of knowledge expressed in an Edge, or a source of data used to generate this knowledge.  |
| resource_role  | (required) The role played by the InformationResource in serving as a source for an Edge (primary_knowledge_source, aggregator_knowledge_source, supporting_data_source).  |
| upstream_resource_ids| (optional) An upstream InformationResource from which the resource being described directly retrieved a record of the knowledge expressed in the Edge, or data used to generate this knowledge. |
| source_record_urls | (optional) A URL linking to a specific web page or document provided by the source that contains a record of the knowledge expressed in the Edge. |


## Implementation Guidance
A quick guide for implementers. Using the model describd above:

1. All Edges MUST report **one and only one** Retrieval Source serving as the `primary knowledge source`. 

2. All Edges MUST provide a list of any Retrieval Sources that served as `aggregator knowledge sources` by retrieving the knowledge expressed in the Edge from the priamry source of another aggregator.  

3. All Edges representing knowledge generated through analysis of data by a Translator Knoledge Provider (KP) SHOULD report any Retrieval Sources providing the data that they operated on as a `supporting data source`. 
4. Values of the `RetrievalSource.resource_id` MUST be an CURIE from the InfoRes Catalog [here]([url](https://github.com/biolink/biolink-model/blob/master/infores_catalog.yaml)) (e.g. â€œinfores:dgidbâ€, â€œinfores:moleproâ€)


## Data Examples

Below we provide JSON data examples illustrating two retrieval scenarios.

**Scenario 1**: Knowledge retrieval from a single external knowledge source 
A single Edge originates in primary source KS1, and is retrieved through multiple aggregators ending with the UI. Along the way, ARA1 merges the two edges retrieved from KP1 and KP1.Â  

![image](https://github.com/NCATSTranslator/ReasonerAPI/assets/5184212/39f08657-f4a5-4410-b2c4-244a9558ef4b)
*KS = an external Knowledge Source. KP = a Translator Knowledge Provider.Â  ARA = a Translator Automated Reasoning Agent, UI  = the Translator User Interface.
Each arrow in the diagram below (R1-R5) represents the distinct retrieval of one edge.*

  ````
  {
  "edges": {
    "subject": "RXCUI:1544384",
    "predicate": "biolink:treats",
    "object": "MONDO:0008383",
    "sources": [
      "type": biolink:RetrievalSource,
      "resource_id": "infores:KS_1",
      "resource_role": "primary knowledge source",
      },
      {                                        # R1
      "type": biolink:RetrievalSource
      "resource_id": "infores:KP_1",
      "resource_role": "aggregator knowledge source",
      "usptream_resource_ids": ["infores:KS_1"]      
      },
      {                                        # R2
      "type": biolink:RetrievalSource,
      "resource_id": "infores:KP_2",
      "resource_role": "aggregator knowledge source",
      "usptream_resource_ids": ["infores:KS_1"]
      },
      {                                        # R3, R4
      "type": biolink:RetrievalSource,
      "resource_id": "infores:ARA1",
      "resource_role": "aggregator knowledge source",
      "usptream_resource_ids": ["infores:KP_1", "infores:KP_2"]
      },
      {                                        # R5
      "type": biolink:RetrievalSource,
      "resource_id": "infores:UI",
      "resource_role": "aggregator knowledge source",
      "usptream_resource_ids": ["infores:ARA_1"]
      },
   ]
 }
````

**Scenario 2:** Retrieveal of knowledge generated by a KP from data 
In this scenario, the knoweldge expressed in the Edge being retrieved was originally generated by a KP based on on analysis of data it retrieved from upstream data sources. This is often the case for KPs like ICEES, COHD, and Multiomics KP that generate Edges reporting statistical corelations between variables in clinical, environmntal, or multiomics datasets. 

In the scenario diagrammed below, data from two soruces (DB1, DB2) is retrieved by KP1, where the data is analyzed to generate an Edge. This makes KP1 the "primary source" of the knowledge, and DB1 and DB2 "supporting data sources". ARA1 then retrieves this edges from KP1 and then passes it along to the UI. 

![image](https://github.com/NCATSTranslator/ReasonerAPI/assets/5184212/40cce738-1235-4ab3-8628-fca92e348761)
*DB = an external data source. KP = a Translator Knowledge Provider.Â  ARA = a Translator Automated Reasoning Agent, UI  = the Translator User Interface.
Each arrow (R1-R5) represents a distinct retrieval event (grey arrows/text indicates the retrieval of *data* rather than knowledge).*

````
    {
    "edges": { 
    "id": "e21aa4542"                         
    "subject": "RXCUI:1544384",
    "predicate": "biolink:correlated_with",
    "object": "MONDO:0008383",
    "sources": [
      {                                        
      "type": biolink:RetrievalSource,
      "resource_id": "infores:DB_1",
      "resource_role": "supporting data source",
      },
      {                                               
      "type": biolink:RetrievalSource,
      "resource_id": "infores:DB_2",
      "resource_role": "supporting data source",
      },
      {                                                
      "type": biolink:Source,                      # R1, R2
      "resource_id": "infores:KP_1",
      "resource_role": "primary knowledge source",
      "upstreams_resource_ids": ["infores:DB_1", "infores:DB_2"]
      },
      {                                            # R3    
      "type": biolink:RetrievalSource,
      "resource_id": "infores:ARA_1",
      "resource_role": "aggregator data source",
      "upstreams_resource_ids": ["infores:KP_1"] 
      },
      {                                            # R4         
      "type": biolink:RetrievalSource,
      "resource_id": "infores:UI",
      "resource_role": "aggregator data source",
      "upstreams_resource_ids": ["infores:ARA_1"] 
      },
    ]
  }
````







================================================
FILE: ImplementationGuidance/Specifications/supporting_publications_specification.md
================================================
# A TRAPI Attribute Specification for Supporting Publications

## Overview

This specification describes how the `biolink:publications` attribute MUST be used by Translator Knowledge Providers (KPs) to report  
publications (broadly defined here to include any document made available for public consumption) that support
a declared Edge.

The Biolink Model describes the `biolink:publications` attribute as follows:
```yaml
publications:
  aliases: ["supporting publications", "supporting documents"]
  is_a: association slot
  description: >-
    A list of one or more publications that report the statement expressed in an Association, 
    or provide information used as evidence supporting this statement. 
    The notion of a â€˜Publicationâ€™ is considered broadly to include any document made   
    available for public consumption. It covers scientific journal issues, individual articles, and
    books - as well as things like pre-prints, white papers, patents, drug
    labels, web pages, protocol documents, and even a part of a publication if
    of significant knowledge scope (e.g. a figure, figure legend, or section
    highlighted by NLP).
  range: publication
```

## Implementation Guidance

1. When a knowledge source reports one or more publication supporting an Edge, KPs MUST use the `biolink:publications` edge property as the `Attribute.attribute_type_id` field, and capture publications as a list in the `Attribute.value` field. e.g.:

        "attribute_type_id": "biolink:publications",
        "value": ["PMID:31737390", "PMID:29076384"]

2. Knowledge sources typically designate supporting publications using a **[CURIE](https://www.w3.org/TR/2010/NOTE-curie-20101216/)** or full
**[URI/URL](https://www.w3.org/Addressing/)**, but may in some cases provide only a **free-text string** title or description. Specific syntax and reporting requirements apply to each designator type:

   a. When a knowledge source provides a **CURIE** for a publication, the ingesting KP MUST ensure that its prefix matches the **spelling and casing** defined in the Biolink Model [prefix map](https://github.com/biolink/biolink-model/blob/master/prefix-map/biolink-model-prefix-map.json) - and make adjustments as necessary. (e.g "PMID" not "pmid", "doi" not "DOI").

   b.  When a knowledge source provides a **URL** for a publication, the ingesting KP MUST report the full URL **EXCEPT** in cases where it contains a Pubmed, Pubmed Central (Europe or NLM), or DOI identifier. Here, the KP MUST convert the URL into CURIE form, e.g.:
    
         http://www.ncbi.nlm.nih.gov/pubmed/29076384    â†’  PMID:29076384  
         https://www.ncbi.nlm.nih.gov/pmc/PMC6246007    â†’  PMCID:6246007
         http://europepmc.org/articles/PMC6246007       â†’  PMC:6246007
         https://doi.org/10.1080/17512433.2018.1398644  â†’  doi:0.1080/17512433.2018.1398644

   c.  When a knowledge source provides a **free-text description** of a supporting publication (e.g. its title, or a bibliographic reference), the ingesting KP MAY capture this text they see fit.
  
    
3. If a knowledge source reports **multiple publications supporting a single Edge**, the ingesting KP SHOULD organize them into Attribute objects according to the specific instructions below.    
  
   a. When all publications supporting the Edge are reported **in CURIE or URI/URL format**, the KP SHOULD capture them as a list in a single Attribute object where the `value_type_id` is "linkml:Uriorcurie":

        {
          "edges": [
            {
              "id": "Association001",
              "subject": "CHEBI:3215",
              "predicate": "biolink:interacts_with",
             "object": "NCBIGene:51176",
              "attributes": [
                {
                  "attribute_type_id": "biolink:publications",
                  "value": [
                    "PMID:31737390",
                    "PMID:6815562",
                    "http://info.gov.hk/gia/general/201011/02/P201011020204.htm"
                  ],
                  "value_type_id": "linkml:Uriorcurie",
                  "attribute_source": "infores:hmdb"
                }
              ]
            }
          ]
        }

  
   b. When all publications supporting the Edge are reported **as free-text descriptions**, the KP SHOULD capture them as a list in a single Attribute object where the `value_type_id` is "linkml:String":

        {
          "edges": [
            {
              "id": "Association001",
              "subject": "CHEBI:3215",
              "predicate": "biolink:interacts_with",
              "object": "NCBIGene:51176",
              "attributes": [
                {
                  "attribute_type_id": "biolink:publications",
                  "value": [
                    "Thematic Review Series: Glycerolipids. Phosphatidylserine and phosphatidylethanolamine in mammalian cells: two metabolically related aminophospholipids",
                    "Toranosuke Saito, Takashi Ishibashi, Tomoharu Shiozaki, Tetsuo Shiraishi, 'Developer for pressure-sensitive recording sheets, aqueous dispersion of the developer and method for preparing the developer.' U.S. Patent US5118443, issued September, 1986.: http://www.google.ca/patents/US5118443"
                  ],
                  "value_type_id": "linkml:String",
                  "attribute_source": "infores:hmdb"
                }
              ]
            }
          ]
        }

   c.  When some of the publications supporting the Edge are in **CURIE/URI format** and others are **free-text**, the ingesting KP MUST **create separate 'publications' Attributes** to hold those reported in CURIE and URI format separately from those described as free-text: 

        {
          "edges": [
            {
              "id": "Association001",
              "subject": "CHEBI:3215",
              "predicate": "biolink:interacts_with",
              "object": "NCBIGene:51176",
              "attributes": [
                {
                  "attribute_type_id": "biolink:publications",
                  "value": [
                    "PMID:31737390",
                    "PMID:6815562",
                    "http://info.gov.hk/gia/general/201011/02/P201011020204.htm"
                  ],
                  "value_type_id": "linkml:Uriorcurie",
                  "attribute_source": "infores:hmdb"
                },
                {
                  "attribute_type_id": "biolink:publications",
                  "value": [
                    "Thematic Review Series: Glycerolipids. Phosphatidylserine and phosphatidylethanolamine in mammalian cells: two metabolically related aminophospholipids",
                    "Toranosuke Saito, Takashi Ishibashi, Tomoharu Shiozaki, Tetsuo Shiraishi, 'Developer for pressure-sensitive recording sheets, aqueous dispersion of the developer and method for preparing the developer.' U.S. Patent US5118443, issued September, 1986.: http://www.google.ca/patents/US5118443"
                  ],
                  "value_type_id": "linkml:String",
                  "attribute_source": "infores:hmdb"
                }
              ]
            }
          ]
        }

   - **NOTE** that the requirement level 'SHOULD' is used above because KPs MAY choose at any time to **separate an individual publication into its own Attribute**, if they wish to provide specific information about it using Attribute fields (e.g. `description`), or using a nested Attribute object. 

4. If a knowledge source provides **multiple identifiers for a single publication supporting an Edge** (e.g. a PMID, PMCID, and DOI for the same journal article), KPs MUST report only one identifier per publication, in the following order of preference: PMID > PMCID > PMC > DOI.  

5. KPs can expect consumers to obtain **metadata about supporting journal articles** that are index by Pubmed (e.g. title, journal, abstract, dates, equivalent identifiers), from the Text Mining Knowledge Providerâ€™s Publication Metadata API. However, the Knowledge Providers MAY use the `Attribute.description` and `Attribute.value_url` fields to provide additional metadata in the TRAPI message itself.

6. Finally, in the short term KPs can continue the current practice of including references to **supporting clinical trial records** alongside references to publications in Attribute objects using the `biolink:publications` edge property. Trial identifiers from clinicaltrials.gov MUST be reported in CURIE format using the prefix "clinicaltrials" (e.g. "clinicaltrials:NCT00222573").

        {
          "attribute_type_id": "biolink:publications",            
          "value": [
                   "PMID:31737390",  
                   "PMID:6815562",  
                   "clinicaltrials:NCT00222573",
                   "clinicaltrials:NCT00503152",
                   "clinicaltrials:NCT00634963"
                   ]                                      
          "value_type_id": "biolink:Uriorcurie",    
          "value_urls":  "https://clinicaltrials.gov/search?id=%22NCT02658760%22OR%22NCT02679560%22OR%22NCT05084573%22",
          "attribute_source": "infores:chembl"
        }, 

   - **NOTE** however that we will soon be moving to **use of a new `supporting_studies` Edge property** to capture supporting clincial trials and other types of studies in a separate Attribute from publications. A specification for this is forthcoming.

### An Important Clarification about Retrieval Source URLs vs Supporting Publications 
Above we define "publications" broadly to include any publicly available document, and include web pages in this scope. However, if a data provider wants to share web pages that display the source record from which they retrieved knowledge expressed in their edge, a URL for this web page should be captured NOT as a supporting publication per the specification above, but rather in the `RetrievalSource` object, per the [Retrieval Provenance Specification](https://github.com/NCATSTranslator/ReasonerAPI/blob/master/ImplementationGuidance/Specifications/retrieval_provenance_specification.md).

For example, consider an edge provided by the **SRI Reference KG** connecting the BRCA2 gene to Hereditary Breast Ovarian Cancer Syndrome, with the following ClinVar record as its primary source:
[image](https://github.com/NCATSTranslator/ReasonerAPI/assets/5184212/9f3be816-b7ff-4709-89bd-c7e314f67bfd)

The SRI KG wants to report the **six journal articles** that ClinVar provides as support for this statement, and also provide the **URL of the ClinVar web page** where the user can explore the source record. Technically, Biolink would consider this ClinVar web page as fitting under its broad definition of 'Publication' - and thus allow for it to be captured in an Attribute using the `publications` edge property.  However, we provide a dedicated `source_record_url` property in the RetrievalSource object for reporting web pages that display the source record from which the KP retrieved knowledge expressed in their edge.  

So in this case, the correct way to capture the six supporting publications and the source record url would be as follows. 

````json
"subject": "BRCA2"
"predicate": "associated with"
"object":  "Hereditary Breast Ovarian Cancer Syndrome"
"sources": [
  {
    "resource_id": "infores:clinvar",
    "resource_role": "primary knowledge source",
    "source_record_url": "https://www.ncbi.nlm.nih.gov/clinvar/variation/9342/"
  },
  {
    "resource_id": "infores:sri-reference-kg",
    "resource_role": "aggregator knowledge source",
    "upstream_resource_ids": "infores:clinvar"
  }
]
"attributes": [
  {
  "attribute_type_id": "biolink:publications",
  "value": ["PMID:12373604", "PMID:18703817", "PMID:24156927", "PMID:18465347", "PMID:22798144", "PMID:26657402"],
  "value_type_id": "linkml:Uriorcurie",
  "attribute_source": "infores:clinvar"
  }
]
````

The key thing to note here is that the URL of the source record from ClinVar is captured not as a `publication`, but as a `source_record_url` - because it is where we want to direct users to explore the primary source of the knowledge expressed in the edge. 



================================================
FILE: tests/test_valid.py
================================================
"""OpenAPI 3.0 validation and examples validation."""
import json
from sys import stderr
import os
import pathlib
import jsonschema
import requests
import yaml
from jsonschema.exceptions import ValidationError
from reasoner_validator import TRAPISchemaValidator


def test_valid():
    """Test whether TranslatorReasonersAPI.yaml is valid OpenAPI 3.0."""
    response = requests.get('https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v3.0/schema.json')
    openapi_schema = json.loads(response.text)

    dir_path = os.path.dirname(os.path.realpath(__file__))
    with open(os.path.join(dir_path, '..', 'TranslatorReasonerAPI.yaml')) as f:
        spec = yaml.load(f, Loader=yaml.SafeLoader)

    jsonschema.validate(spec, openapi_schema)


def test_message_examples():
    dir_path = os.path.dirname(os.path.realpath(__file__))
    with open(os.path.join(dir_path, '..', 'TranslatorReasonerAPI.yaml')) as f:
        spec = yaml.load(f, Loader=yaml.SafeLoader)
        print(spec)
    dir_path_json = os.path.join(dir_path, '../examples/Message')
    for filename in os.listdir(dir_path_json):
        full_path = os.path.join(dir_path_json, filename)
        file_extension = pathlib.Path(full_path).suffix
        if file_extension == '.json':
            with open(full_path) as f:
                print(full_path)
                example = json.load(f)
                trapi_version_locally = spec['info']['x-trapi']['version']
                validator = TRAPISchemaValidator(trapi_version=trapi_version_locally)
                print(validator.trapi_version)
                try:
                    validator.validate(
                        instance=example,
                        component="Message"
                    )
                except ValidationError:
                    print(validator.to_dict(), file=stderr)
                    raise ValueError('TRAPI example is not valid against the trapi_version specified!')


def metakg_examples():  # def test_metakg_examples():
    mtest_directory('../examples/MetaKnowledgeGraph', 'MetaKnowledgeGraph')
    mtest_directory('../examples/Message', 'Message')


def mtest_directory(json_path, object_to_validate):
    dir_path = os.path.dirname(os.path.realpath(__file__))
    with open(os.path.join(dir_path, '..', 'TranslatorReasonerAPI.yaml')) as f:
        spec = yaml.load(f, Loader=yaml.SafeLoader)
    dir_path_json = os.path.join(dir_path, json_path)
    for filename in os.listdir(dir_path_json):
        full_path = os.path.join(dir_path_json, filename)
        file_extension = pathlib.Path(full_path).suffix
        if file_extension == '.json':
            with open(full_path) as f:
                example = json.load(f)
                trapi_version_locally = spec['info']['x-trapi']['version']
                validator = TRAPISchemaValidator(trapi_version=trapi_version_locally)
                try:
                    validator.validate(
                        instance=example,
                        component=object_to_validate
                    )
                except ValidationError:
                    print(validator.to_dict(), file=stderr)
                    raise ValueError('TRAPI example is not valid against the trapi_version specified!')

